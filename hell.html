<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SUFFERING IS ETERNAL</title>
    <link rel="stylesheet" href="index.css">
    <style>
        /* Embed ModernDOS font - using web font alternative */
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
        
        @font-face {
            font-family: 'ModernDOS';
            src: local('Courier New'), local('Courier'), monospace;
            font-weight: normal;
            font-style: normal;
        }
        
        /* Use Share Tech Mono as ModernDOS alternative (DOS-style monospace) */
        .modern-dos-font {
            font-family: 'Share Tech Mono', 'Courier New', Courier, monospace !important;
        }
        
        /* Apply ModernDOS to questions 100+ */
        .question-modern-dos {
            font-family: 'Share Tech Mono', 'Courier New', Courier, monospace !important;
        }
        
        /* Green text for questions 110+ */
        .question-green {
            color: #00ff00 !important;
        }
        
        /* Remove background for questions 120+ */
        .no-background {
            background: none !important;
            background-color: #000000 !important;
        }
        
        /* Simplistic theme for questions 130+ */
        .simplistic-theme {
            background: #000000 !important;
            color: #00ff00 !important;
        }
        
        .simplistic-theme .container {
            background: transparent !important;
            border: 1px solid #00ff00 !important;
        }
        
        .simplistic-theme .container button {
            background: #000000 !important;
            color: #00ff00 !important;
            border: 1px solid #00ff00 !important;
        }
        
        .simplistic-theme a {
            color: #00ff00 !important;
        }
        
        body {
            background: url("hell1.jpg") no-repeat center center fixed;
            background-size: cover;
        }

        .container button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background-color: #ffb9b9;
            color: rgb(104, 104, 104);
            border: none;
            border-radius: 5px;
            font-size: 1.2em;
            cursor: pointer;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            z-index: -1;
        }
        a {
            text-decoration: none;
            color: #ffbaba;
            font-size: x-large;
        }
    </style>
</head>

<body>
    <div class="status">
        <span class="name hide"></span>
        <a login href="signin.html">Login</a>
        <a signup href="signup.html">Signup</a>
        <a logout class="hide" href="index.html">Log out</a>
        <a giveup href="index.html">Give up</a>
    </div>
    <div class="container">
        <div class="question" id="ques"></div>
        <div class="options" id="opt"></div>
        <button onclick="checkAns()" id="btn">SUBMIT</button>
        <div class="correctanswer"></div>
        <div class="jum" style="display: flex; justify-content: space-between;">
            <div id="score"></div>
            <div id="timeelapsed"></div>
        </div>
        <div class="timerifinvalid"></div>
        <div class="evalscreen" style="display:none"></div>
        <div id="notification" class="notification hide"></div>
    </div>
    <script type="module" src="./IR.js"></script>
    <script type="module" src="./firebase.js"></script>
    <script type="module" src="./hm.js"></script>
</body>
<script type="module">

    import { getAuth, getFirestore, collection, addDoc } from "./firebase.js";
    const auth = getAuth();

    let allQuestions = [];
    
    // Gamepad support
    let gamepadConnected = false;
    let gamepadPollInterval = null;
    let lastDpadState = { up: false, down: false, left: false, right: false };
    let answerOptions = []; // Store current question's answer options for controller support
    
    // Add controller and keyboard indicators to submit button
    const submitBtn = document.querySelector("#btn");
    let controllerIndicator = null;
    let keyboardSubmitIndicator = null;
    if (submitBtn) {
        controllerIndicator = document.createElement("img");
        controllerIndicator.className = "controller-submit-indicator";
        controllerIndicator.src = "btns/cross.png";
        controllerIndicator.alt = "A/X Button";
        controllerIndicator.title = "Press A or X button to submit";
        controllerIndicator.style.cssText = `
            display: inline-block;
            margin-left: 8px;
            width: 28px;
            height: 28px;
            vertical-align: middle;
            object-fit: contain;
        `;
        submitBtn.appendChild(controllerIndicator);
        
        keyboardSubmitIndicator = document.createElement("span");
        keyboardSubmitIndicator.className = "keyboard-submit-indicator";
        keyboardSubmitIndicator.textContent = "Space/Enter";
        keyboardSubmitIndicator.title = "Press Space or Enter to submit";
        keyboardSubmitIndicator.style.cssText = `
            display: inline-block;
            margin-left: 8px;
            padding: 4px 8px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            vertical-align: middle;
        `;
        submitBtn.appendChild(keyboardSubmitIndicator);
    }
    
    // Keyboard support
    function initKeyboard() {
        document.addEventListener("keydown", (e) => {
            const evalDiv = document.querySelector(".evalscreen");
            if (evalDiv && evalDiv.style.display !== "none" && evalDiv.style.display !== "") {
                return;
            }
            if (!allQuestions || allQuestions.length === 0) {
                return;
            }
            if (e.key >= "1" && e.key <= "4") {
                const index = parseInt(e.key) - 1;
                if (answerOptions && answerOptions[index]) {
                    answerOptions[index].checked = true;
                    e.preventDefault();
                }
            }
            if (e.key === " " || e.key === "Enter") {
                if (submitBtn && submitBtn.style.display !== "none") {
                    checkAns();
                    e.preventDefault();
                }
            }
        });
    }
    initKeyboard();
    
    document.querySelector('#btn').addEventListener('click', checkAns);
    const ques = document.getElementById("ques");

    async function fetchQuestions() {
        try {
            // OpenTDB has a 50 question limit per request, so make multiple requests
            const totalQuestions = 200;
            const questionsPerRequest = 50;
            const numRequests = Math.ceil(totalQuestions / questionsPerRequest);
            
            allQuestions.length = 0; // Clear any previous questions
            let failedRequests = 0;
            
            for (let i = 0; i < numRequests; i++) {
                // Add delay between API calls to prevent rate limiting (except before first request)
                if (i > 0) {
                    await new Promise(resolve => setTimeout(resolve, 500)); // 500ms delay
                }
                
                const amount = i === numRequests - 1 
                    ? totalQuestions - (i * questionsPerRequest) 
                    : questionsPerRequest;
                
                try {
                    const response = await fetch(`https://opentdb.com/api.php?amount=${amount}&difficulty=hard&type=multiple`);
                    if (!response.ok) {
                        console.warn(`Request ${i + 1} failed with status ${response.status}`);
                        failedRequests++;
                        continue;
                    }
                    const data = await response.json();
                    if (data.results && data.results.length > 0) {
                        allQuestions.push(...data.results);
                    } else {
                        console.warn(`Request ${i + 1} returned no questions`);
                        failedRequests++;
                    }
                } catch (requestError) {
                    console.error(`Error in request ${i + 1}:`, requestError);
                    failedRequests++;
                }
            }
            
            // Validate we got questions
            if (allQuestions.length === 0) {
                throw new Error("Failed to fetch any questions. Please try again.");
            }
            
            // Warn if we got fewer questions than expected
            if (allQuestions.length < totalQuestions) {
                console.warn(`Warning: Expected ${totalQuestions} questions but got ${allQuestions.length}. Continuing with available questions.`);
            }
        } catch (error) {
            console.error("Error fetching questions:", error);
            document.querySelector('#btn').innerHTML = "Refresh";
            document.querySelector('#btn').onclick = () => {
                location.reload();
            };
            ques.innerHTML = `<h5 style='color: red'>${error.message || error}</h5>`;
        }
    }
    let currQuestion = 0;
    let score = 0;
    let elapsedQuestions = 0;
    let totalGradePoints = 0; // Track accumulated grade points
    let questionStartTime = null; // Track when each question starts (for time bonus calculation)
    let timeToAnswer = null; // Track time allocated for current question
    let initialTimeToAnswer = null; // Track initial time allocated for current question
    let quizAbandoned = false; // Track if quiz was abandoned (gave up)

    ques.innerHTML = `<h5>Please Wait!! Loading Questions...</h5>`;
    document.querySelector('#btn').style.display = "none";
    
    // Handle give up button
    const giveUpBtn = document.querySelector("[giveup]");
    if (giveUpBtn) {
        giveUpBtn.addEventListener("click", (e) => {
            e.preventDefault();
            if (confirm("Are you sure you want to give up? Your current progress will be saved.")) {
                quizAbandoned = true; // Mark quiz as abandoned
                evalScreen();
            }
        });
    }

    async function startQuiz() {
        await fetchQuestions();
        if (allQuestions.length === 0) {
            ques.innerHTML = `<h5 style='color: red'>Unable to fetch data, Please try again!!</h5>`;
            document.querySelector('#btn').style.display = "block";
            document.querySelector('#btn').innerHTML = "Refresh";
            document.querySelector('#btn').onclick = () => {
                location.reload();
            };
        } else {
            loadQues();
            stopWatch();
        }
    }
    startQuiz();
    
    // Update indicator visibility based on controller connection
    function updateIndicatorVisibility() {
        const controllerIndicators = document.querySelectorAll(".controller-indicator, .controller-submit-indicator");
        const keyboardIndicators = document.querySelectorAll(".keyboard-indicator, .keyboard-submit-indicator");
        
        if (gamepadConnected) {
            controllerIndicators.forEach(indicator => {
                indicator.style.display = "inline-block";
            });
            keyboardIndicators.forEach(indicator => {
                indicator.style.display = "none";
            });
        } else {
            controllerIndicators.forEach(indicator => {
                indicator.style.display = "none";
            });
            keyboardIndicators.forEach(indicator => {
                indicator.style.display = "inline-block";
            });
        }
    }

    // Gamepad support functions
    function initGamepad() {
        window.addEventListener("gamepadconnected", (e) => {
            gamepadConnected = true;
            startGamepadPolling();
            updateIndicatorVisibility();
        });
        
        window.addEventListener("gamepaddisconnected", (e) => {
            gamepadConnected = false;
            stopGamepadPolling();
            updateIndicatorVisibility();
        });
        
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                gamepadConnected = true;
                startGamepadPolling();
                break;
            }
        }
        updateIndicatorVisibility();
    }
    
    function startGamepadPolling() {
        if (gamepadPollInterval) return;
        gamepadPollInterval = setInterval(() => {
            const gamepads = navigator.getGamepads();
            for (let i = 0; i < gamepads.length; i++) {
                const gamepad = gamepads[i];
                if (gamepad) {
                    handleGamepadInput(gamepad);
                    break;
                }
            }
        }, 50);
    }
    
    function stopGamepadPolling() {
        if (gamepadPollInterval) {
            clearInterval(gamepadPollInterval);
            gamepadPollInterval = null;
        }
    }
    
    function handleGamepadInput(gamepad) {
        let dpadUp = false, dpadDown = false, dpadLeft = false, dpadRight = false;
        
        if (gamepad.buttons[12]) dpadUp = gamepad.buttons[12].pressed;
        if (gamepad.buttons[13]) dpadDown = gamepad.buttons[13].pressed;
        if (gamepad.buttons[14]) dpadLeft = gamepad.buttons[14].pressed;
        if (gamepad.buttons[15]) dpadRight = gamepad.buttons[15].pressed;
        
        if (gamepad.axes.length >= 10) {
            const hatX = gamepad.axes[9];
            const hatY = gamepad.axes[10];
            if (hatY < -0.5) dpadUp = true;
            if (hatY > 0.5) dpadDown = true;
            if (hatX < -0.5) dpadLeft = true;
            if (hatX > 0.5) dpadRight = true;
        }
        
        if (dpadUp && !lastDpadState.up && answerOptions.length >= 1) {
            answerOptions[0].checked = true;
            lastDpadState.up = true;
        } else if (!dpadUp) {
            lastDpadState.up = false;
        }
        
        if (dpadRight && !lastDpadState.right && answerOptions.length >= 2) {
            answerOptions[1].checked = true;
            lastDpadState.right = true;
        } else if (!dpadRight) {
            lastDpadState.right = false;
        }
        
        if (dpadDown && !lastDpadState.down && answerOptions.length >= 3) {
            answerOptions[2].checked = true;
            lastDpadState.down = true;
        } else if (!dpadDown) {
            lastDpadState.down = false;
        }
        
        if (dpadLeft && !lastDpadState.left && answerOptions.length >= 4) {
            answerOptions[3].checked = true;
            lastDpadState.left = true;
        } else if (!dpadLeft) {
            lastDpadState.left = false;
        }
        
        if ((gamepad.buttons[0] && gamepad.buttons[0].pressed) || 
            (gamepad.buttons[2] && gamepad.buttons[2].pressed)) {
            if (!window.gamepadSubmitPressed) {
                window.gamepadSubmitPressed = true;
                checkAns();
            }
        } else {
            window.gamepadSubmitPressed = false;
        }
    }
    
    initGamepad();
    
    // BGM for hell mode (multiple stages like master)
    let bgm3, bgm4, bgm5, bgm6;
    let currentBGM = null;
    let currentStage = -1;
    
    function playBGM() {
        if (!bgm3) {
            bgm3 = new Audio("bgm/stage4.mp3");
            bgm4 = new Audio("bgm/stage5.mp3");
            bgm5 = new Audio("bgm/stage3.mp3");
            bgm6 = new Audio("bgm/stage6.mp3");
            bgm4.loop = true;
            bgm5.loop = true;
            bgm3.loop = true;
            bgm6.loop = true;
        }
        
        // Stop BGM on final question of each stage (for 200 questions: 49, 99, 149, 199)
        if (currQuestion === 49 || currQuestion === 99 || currQuestion === 149 || currQuestion === 199) {
            if (currentBGM) {
                currentBGM.pause();
                currentBGM.currentTime = 0;
                currentBGM = null;
                currentStage = -1;
            }
            return;
        }
        
        let targetStage, targetBGM;
        if (currQuestion < 50) {
            targetStage = 1;
            targetBGM = bgm3;
        } else if (currQuestion < 100) {
            targetStage = 2;
            targetBGM = bgm4;
        } else if (currQuestion < 130) {
            targetStage = 3;
            targetBGM = bgm5;
        } else {
            targetStage = 4;
            targetBGM = bgm6;
        }
        
        if (currentStage !== targetStage) {
            if (currentBGM) {
                currentBGM.pause();
                currentBGM.currentTime = 0;
            }
            currentBGM = targetBGM;
            currentStage = targetStage;
            currentBGM.play().catch(err => console.log("BGM play failed:", err));
        }
    }
    
    function stopBGM() {
        if (currentBGM) {
            currentBGM.pause();
            currentBGM.currentTime = 0;
            currentBGM = null;
            currentStage = -1;
        }
    }

    function loadQues() {
        const opt = document.getElementById("opt");
        let currentQuestion = allQuestions[currQuestion].question;
        // Decode HTML entities in the question and answers
        function decodeHTMLEntities(text) {
            if (!text) return "";
            const txt = document.createElement('textarea');
            txt.innerHTML = text;
            return txt.value;
        }
        currentQuestion = decodeHTMLEntities(currentQuestion);
        ques.innerHTML = currentQuestion;
        
        // Apply styling based on question number
        const questionElement = document.getElementById("ques");
        const containerElement = document.querySelector(".container");
        const bodyElement = document.body;
        
        // Reset all classes first
        questionElement.classList.remove("question-modern-dos", "question-green");
        bodyElement.classList.remove("no-background", "simplistic-theme");
        
        // Question 100+: ModernDOS font
        if (currQuestion >= 100) {
            questionElement.classList.add("question-modern-dos", "modern-dos-font");
        } else {
            questionElement.classList.remove("modern-dos-font");
        }
        
        // Question 110+: Green text
        if (currQuestion >= 110) {
            questionElement.classList.add("question-green");
        }
        
        // Question 120+: Remove background
        if (currQuestion >= 120) {
            bodyElement.classList.add("no-background");
            bodyElement.style.backgroundImage = "none";
            bodyElement.style.backgroundColor = "#000000";
        } else {
            // Call changeBackground to set the appropriate background for questions < 120
            changeBackground();
        }
        
        // Question 130+: Simplistic theme
        if (currQuestion >= 130) {
            bodyElement.classList.add("simplistic-theme");
            if (containerElement) {
                containerElement.style.background = "transparent";
                containerElement.style.border = "1px solid #00ff00";
                containerElement.style.color = "#00ff00";
            }
        } else {
            if (containerElement) {
                containerElement.style.background = "";
                containerElement.style.border = "";
                containerElement.style.color = "";
            }
        }
        
        opt.innerHTML = "";
        
        // Set background based on question number (if not in simplistic theme)
        if (currQuestion < 120) {
            changeBackground();
        }
        
        loadScore();
        const correctAnswer = allQuestions[currQuestion].correct_answer;
        const incorrectAnswers = allQuestions[currQuestion].incorrect_answers;
        const options = [correctAnswer, ...incorrectAnswers];
        options.sort(() => Math.random() - 0.5);
        
        // Store options for controller support
        answerOptions = [];
        
        // Controller button mapping: Up, Right, Down, Left
        const controllerButtonImages = ["btns/up.png", "btns/right.png", "btns/down.png", "btns/left.png"];
        const controllerLabels = ["D-Pad Up", "D-Pad Right", "D-Pad Down", "D-Pad Left"];
        
        options.forEach((option, index) => {
            const decodedOption = decodeHTMLEntities(option);
            const choicesdiv = document.createElement("div");
            const choice = document.createElement("input");
            const choiceLabel = document.createElement("label");
            choice.type = "radio";
            choice.name = "answer";
            choice.value = decodedOption;
            choiceLabel.textContent = decodedOption;
            
            // Apply ModernDOS font to options for questions 100+
            if (currQuestion >= 100) {
                choiceLabel.style.fontFamily = "'Share Tech Mono', 'Courier New', Courier, monospace";
            }
            
            // Apply green color to options for questions 110+
            if (currQuestion >= 110) {
                choiceLabel.style.color = "#00ff00";
            }
            
            // Add controller button indicator
            const controllerIndicator = document.createElement("img");
            controllerIndicator.className = "controller-indicator";
            controllerIndicator.src = controllerButtonImages[index] || "";
            controllerIndicator.alt = controllerLabels[index] || "";
            controllerIndicator.title = controllerLabels[index] || "";
            controllerIndicator.style.cssText = `
                display: inline-block;
                margin-right: 8px;
                width: 32px;
                height: 32px;
                vertical-align: middle;
                object-fit: contain;
            `;
            
            // Add keyboard indicator
            const keyboardIndicator = document.createElement("span");
            keyboardIndicator.className = "keyboard-indicator";
            keyboardIndicator.textContent = (index + 1).toString();
            keyboardIndicator.title = `Press ${index + 1} to select this answer`;
            keyboardIndicator.style.cssText = `
                display: inline-block;
                margin-right: 8px;
                padding: 4px 8px;
                background-color: rgba(255, 255, 255, 0.2);
                border: 2px solid rgba(255, 255, 255, 0.5);
                border-radius: 4px;
                font-size: 16px;
                font-weight: bold;
                color: white;
                vertical-align: middle;
                min-width: 24px;
                text-align: center;
            `;
            
            choicesdiv.appendChild(choice);
            choicesdiv.appendChild(controllerIndicator);
            choicesdiv.appendChild(keyboardIndicator);
            choicesdiv.appendChild(choiceLabel);
            opt.appendChild(choicesdiv);
            document.querySelector('#btn').style.display = "block";
            
            // Set initial visibility
            if (gamepadConnected) {
                controllerIndicator.style.display = "inline-block";
                keyboardIndicator.style.display = "none";
            } else {
                controllerIndicator.style.display = "none";
                keyboardIndicator.style.display = "inline-block";
            }
            
            // Make the div clickable to select the option
            choicesdiv.addEventListener("click", () => {
                choice.checked = true;
            });
            
            // Store reference for controller support
            answerOptions.push(choice);
        });

        let answerTimerId; // Store interval ID for answer timer
        // Clear any previous interval to prevent multiple timers
        if (window.answerTimerId) {
            clearInterval(window.answerTimerId);
        }
        const timerDiv = document.querySelector(".timerifinvalid");
        if (quizMinutes >= 15) {
            // Add 1s countdown timer for each question when stopwatch hits 15 minutes (hell mode)
            timeToAnswer = 1; // 1 second for hell mode
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "red";
        } else if (currQuestion < 10) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 12;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        } 
        else if (currQuestion < 20) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 11.5;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }
        else if (currQuestion < 30) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 11;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }        else if (currQuestion < 40) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 10;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }
        else if (currQuestion < 50) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 9;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }
        else if (currQuestion < 60) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 8.5;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }
        else if (currQuestion < 110) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 7.5;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }
        else if (currQuestion < 120) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 6;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }else if (currQuestion < 130) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 4;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }
        else if (currQuestion < 140) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 3.5;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }
        else if (currQuestion < 150) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 3;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }
        else if (currQuestion < 160) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 2.5;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }
        else if (currQuestion < 180) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 2;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }
        else if (currQuestion < 190) { // This will converge to a very strict time curve over the span of the quiz, trust me (scaled for 200 questions)
            timeToAnswer = 1.75;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }
        else if (currQuestion <= allQuestions.length) {
            timeToAnswer = 1.5;
            initialTimeToAnswer = timeToAnswer; // Store initial time for grade calculation
            window.answerTimerId = setInterval(() => {
                if (timeToAnswer > 0) {
                    timeToAnswer -= 0.01;
                    timerDiv.innerHTML = `${timeToAnswer.toFixed(2)}`;
                } else {
                    clearInterval(window.answerTimerId);
                    evalScreen();
                }
            }, 10);
            timerDiv.style.display = "block";
            timerDiv.style.textAlign = "center";
            timerDiv.style.fontSize = "xx-large";
            timerDiv.style.color = "white";
        }
        document.querySelector(".correctanswer").innerHTML = "";
        
        // Track question start time for grade points calculation
        questionStartTime = Date.now();
        // Store initial time for this question (will be set in timer logic below)
        // We'll capture it from the first timer setup
        
        // Update indicator visibility after loading question
        updateIndicatorVisibility();
        
        // Update BGM based on current question
        playBGM();
    }
    function changeBackground() {
        // Use the global currQuestion variable (question index) to determine background
        // Only change background if not in simplistic theme (questions 120+)
        if (currQuestion < 120) {
            if (currQuestion < 10) {
                document.body.style.background = "url('hell1.jpg') no-repeat center center fixed";
                document.body.style.backgroundSize = "cover";
            } else if (currQuestion < 20) {
                document.body.style.background = "url('hell2.jpg') no-repeat center center fixed";
                document.body.style.backgroundSize = "cover";
            } else if (currQuestion < 30) {
                document.body.style.background = "url('hell3.jpg') no-repeat center center fixed";
                document.body.style.backgroundSize = "cover";
            } else if (currQuestion < 40) {
                document.body.style.background = "url('hell4.jpg') no-repeat center center fixed";
                document.body.style.backgroundSize = "cover";
            } else if (currQuestion < 50) {
                document.body.style.background = "url('hell5.jpg') no-repeat center center fixed";
                document.body.style.backgroundSize = "cover";
            } else if (currQuestion < 60) {
                document.body.style.background = "url('hell6.jpg') no-repeat center center fixed";
                document.body.style.backgroundSize = "cover";
            } else if (currQuestion < 70) {
                document.body.style.background = "url('hell7.jpg') no-repeat center center fixed";
                document.body.style.backgroundSize = "cover";
            } else if (currQuestion < 80) {
                document.body.style.background = "url('hell8.jpg') no-repeat center center fixed";
                document.body.style.backgroundSize = "cover";
            } else if (currQuestion < 90) {
                document.body.style.background = "url('hell9.jpg') no-repeat center center fixed";
                document.body.style.backgroundSize = "cover";
            } else if (currQuestion < 100) {
                document.body.style.background = "url('hell10.jpg') no-repeat center center fixed";
                document.body.style.backgroundSize = "cover";
            } else if (currQuestion < 120) {
                // Questions 100-119: keep last background or use a default
                document.body.style.background = "url('hell10.jpg') no-repeat center center fixed";
                document.body.style.backgroundSize = "cover";
            }
        }
    }
    // Calculate grade points for a question
    function internalGrade() {
        // Validate quiz state
        if (!allQuestions || allQuestions.length === 0) {
            console.warn("No questions loaded");
            return 0;
        }
        
        if (currQuestion < 0 || currQuestion >= allQuestions.length) {
            console.warn("Invalid question index");
            return 0;
        }
        
        // Get selected answer from DOM
        const selectedAns = document.querySelector('input[name="answer"]:checked');
        if (!selectedAns) {
            return 0;
        }
        
        // Decode HTML entities for comparison
        function decodeHTMLEntities(text) {
            if (!text) return "";
            const txt = document.createElement("textarea");
            txt.innerHTML = text;
            return txt.value;
        }
        
        const answerValue = selectedAns.value;
        const correctAnswer = allQuestions[currQuestion].correct_answer;
        const decodedAnswerValue = decodeHTMLEntities(answerValue);
        const decodedCorrectAnswer = decodeHTMLEntities(correctAnswer);
        
        // Check if answer is correct
        const isCorrect = decodedAnswerValue === decodedCorrectAnswer || answerValue === correctAnswer;
        
        if (!isCorrect) {
            return 0;
        }
        
        // Calculate remaining time factor (hell mode has per-question timers)
        let timeRatio;
        if (!initialTimeToAnswer || initialTimeToAnswer <= 0) {
            // Fallback: use 30 seconds if no timer was set
            const timeTaken = questionStartTime ? (Date.now() - questionStartTime) / 1000 : 0;
            const timeBonus = 30;
            const remainingTime = Math.max(0, timeBonus - timeTaken);
            timeRatio = remainingTime * 10 / timeBonus;
        } else {
            // Get remaining time (clamp to 0 if negative)
            const remainingTime = Math.max(0, timeToAnswer || 0);
            // Calculate remaining time ratio (0.0 to 1.0)
            timeRatio = remainingTime * 10 / initialTimeToAnswer;
        }
        
        // Base score for each question
        const quesScore = 500;
        
        // Difficulty multiplier based on question number (similar to master mode)
        let multiplier;
        if (currQuestion < 50) {
            multiplier = 1;
        } else if (currQuestion < 100) {
            multiplier = 2;
        } else if (currQuestion < 150) {
            multiplier = 4;
        } else {
            multiplier = 7;
        }
        
        // Calculate grade points with remaining time as a factor
        const questionPoints = quesScore * multiplier * timeRatio;
        
        return Math.round(questionPoints);
    }

    let quizMinutes = 0; // Global variable to track minutes
    let timer; // Global variable to store the timer interval
    let grade;
    function stopWatch() {
        const startTime = Date.now();
        const timeDisplay = document.getElementById("timeelapsed");
        timer = setInterval(() => {
            const elapsedTime = Date.now() - startTime;
            const miliseconds = Math.floor((elapsedTime % 1000) / 10);
            const seconds = Math.floor((elapsedTime / 1000) % 60);
            quizMinutes = Math.floor((elapsedTime / (1000 * 60)) % 60);
            timeDisplay.innerHTML = `${quizMinutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${miliseconds.toString().padStart(2, '0')}`;
            if ((quizMinutes >= 3 && currQuestion >= 50) || (quizMinutes >= 5 && currQuestion >= 100) || (quizMinutes >= 6 && currQuestion >= 130)) {
                alert("Excellent! ...but let's go better next time"); // TGM3 torikan line (scaled for 200 questions)
                evalScreen();
            }
            if (quizMinutes >= 10) {
                timeDisplay.style.color = "yellow";
            }
            if (quizMinutes >= 12) {
                timeDisplay.style.color = "orange";
            }
            if (quizMinutes >= 15) {
                alert("You took too long! This run has been invalidated.");
                timeDisplay.style.color = "red";
            }
        }, 10);
        timeDisplay.style.fontSize = "xx-large";
        timeDisplay.style.textAlign = "center";
    }

    function loadScore() {
        const totalScore = document.getElementById("score");
        totalScore.innerHTML = `${score}`;
        totalScore.style.fontSize = "xx-large";
        totalScore.style.color = "pink";
    }
    function evalScreen() {
        // Stop BGM when quiz ends
        stopBGM();
        
        // Hide the give up button when evaluation screen is displayed
        const giveUpBtn = document.querySelector("[giveup]");
        if (giveUpBtn) {
            giveUpBtn.style.display = "none";
        }
        
        document.getElementById("opt").remove();
        document.getElementById("ques").remove();
        document.getElementById("btn").remove();
        document.getElementById("score").remove();
        const evalDiv = document.querySelector(".evalscreen");
        
        // Check if player completed hell mode (all questions answered correctly, not abandoned)
        // When evalScreen is called from nextQuestion, currQuestion is at the last question index
        // We've completed if we answered all questions correctly (score equals total questions)
        const isCompleted = !quizAbandoned && currQuestion >= allQuestions.length - 1 && score === allQuestions.length && quizMinutes < 15;
        
        // Clear all timers
        clearInterval(timer);
        if (window.answerTimerId) {
            clearInterval(window.answerTimerId);
        }
        
        const timeElapsedDiv = document.getElementById("timeelapsed");
        const timerDiv = document.querySelector(".timerifinvalid");
        timerDiv.style.display = "none";

        // Calculate grade for submission (needed for both screens)
        let grade = "";
        let evalPercent = allQuestions.length > 0 ? (score / allQuestions.length) * 200 : 0;
        
        if (quizMinutes >= 15) {
            grade = "Invalid";
        } 
        else if (evalPercent == 200 && quizMinutes < 5) {
            grade = "Grand Master - Infinity";
        }
        else if (allQuestions.length > 0) {
            // Floor division by 10 to get grade number (0-20)
            let ngrade = Math.floor(evalPercent / 10);
            // Grade format: S1, S2, S3, ..., S20 (or empty string if 0)
            grade = ngrade > 0 ? "S" + ngrade : "";
        } else {
            grade = "";
        }
        
        // Show credits screen if completed, otherwise show evaluation screen
        if (isCompleted) {
            // Automatically submit score for completed runs
            const user = auth.currentUser;
            if (user) {
                // Submit score automatically without user interaction
                (async function autoSubmitScore() {
                    try {
                        const db = getFirestore();
                        const payload = {
                            name: user.displayName || user.email,
                            score: score,
                            grade: grade,
                            time: timeElapsedDiv ? timeElapsedDiv.textContent : 'N/A',
                            date: new Date().toLocaleString()
                        };

                        // Global leaderboard entry
                        await addDoc(collection(db, 'scoresfinal'), payload);
                        // Per‑player data entry
                        await addDoc(collection(db, 'playerData', user.uid, 'hell'), payload);
                        console.log("Score submitted automatically");
                    } catch (error) {
                        console.error("Error auto-submitting score:", error);
                    }
                })();
            }
            
            // Credits screen
            evalDiv.innerHTML = `
                <div style="color: #00ff00; font-family: 'Share Tech Mono', 'Courier New', Courier, monospace; background: #000000; padding: 40px; min-height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                    <h1 style="font-size: 3em; margin-bottom: 30px; text-align: center;">CREDITS</h1>
                    <div style="font-size: 1.5em; line-height: 2; text-align: center; max-width: 800px;">
                        <p style="margin: 20px 0;">Congratulations on completing HELL MODE</p>
                        <p style="margin: 20px 0;">You have proven yourself worthy</p>
                        <br>
                        <br>
                        <p style="margin: 20px 0;">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</p>
                        <br>
                        <p style="margin: 20px 0;">DEVELOPED BY</p>
                        <p style="margin: 20px 0;">Neneko</p>
                        <br>
                        <p style="margin: 20px 0;">SPECIAL THANKS</p>
                        <p style="margin: 20px 0;">To all the players who dared to enter HELL (how many again?)</p>
                        <br>
                        <p style="margin: 20px 0;">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</p>
                        <br>

                    </div>
                </div>
            `;
            
            // After 10 seconds, show grade screen
            setTimeout(() => {
                evalDiv.innerHTML = `
                    <div style="color: #00ff00; font-family: 'Share Tech Mono', 'Courier New', Courier, monospace; background: #000000; padding: 40px; min-height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                        <h1 style="font-size: 4em; margin-bottom: 50px; text-align: center;">YOU ARE</h1>
                        <div style="font-size: 6em; margin: 50px 0; text-align: center; font-weight: bold;">
                            ${grade || "N/A"}
                        </div>
                        <p style="margin: 20px 0; font-size: 0.9em;">Thank you for playing.</p>
                    </div>
                `;
                
                // After 10 more seconds (20 total), redirect to home
                setTimeout(() => {
                    location.href = 'index.html';
                }, 10000); // 10 seconds
            }, 10000); // 10 seconds
        } else {
            // Regular evaluation screen
            evalDiv.innerHTML = `<h3>Game Over.</h3>
                        <p style="font-size:larger">Your score is:</p>
                        <div class="eval" style="display:flex; justify-content:space-between;">
                        <div id="score" >
                        <span class="score" style="font-size:4em">${score}</span> <span style="font-size:xx-large">/ ${allQuestions.length}</span>
                        </div>
                        <div id=grade>
                        <span class="grade" style="font-size:6em">${grade}</span>
                        </div>
                        </div>
                        <p>Thank you for playing!</p>
                    <button onclick="location.reload()">Play Again</button>
                    <button class="submitsuffering">Submit your suffe- I mean score</button>
                    <button class="home" onclick="location.href='index.html'">Home</button>`;
        }
        
        evalDiv.style.display = "block";
        evalDiv.style.textAlign = "center";
        
        // Only show submit button and handle submission for non-completed runs
        if (!isCompleted) {
            // Attach event listener after button is created
            const user = auth.currentUser;
            const submitBtn = document.querySelector(".submitsuffering");

            if (!submitBtn) {
                return;
            }

            if (!user) {
                submitBtn.textContent = "Login to submit score";
                submitBtn.onclick = () => {
                    location.href = "signin.html";
                };
                return;
            }

            let isSubmitting = false;

            async function submitHellScore() {
                if (isSubmitting || submitBtn.disabled) return;

                // Prevent abandoned scores from being submitted
                if (quizAbandoned) {
                    alert("Abandoned runs cannot be submitted to the leaderboards.");
                    submitBtn.disabled = true;
                    submitBtn.textContent = "Abandoned runs cannot be submitted";
                    submitBtn.style.cursor = "not-allowed";
                    return;
                }

                // Prevent invalid scores from being submitted
                if (quizMinutes >= 15) {
                    alert("Invalid run! Scores cannot be submitted for runs that took 15 minutes or longer.");
                    return;
                }

                isSubmitting = true;
                submitBtn.disabled = true;
                submitBtn.textContent = "Submitting...";

                try {
                    const db = getFirestore();
                    const payload = {
                        name: user.displayName || user.email,
                        score: score,
                        grade: grade,
                        time: document.getElementById("timeelapsed").textContent,
                        date: new Date().toLocaleString()
                    };

                    // Global leaderboard entry
                    await addDoc(collection(db, 'scoresfinal'), payload);
                    // Per‑player data entry
                    await addDoc(collection(db, 'playerData', user.uid, 'hell'), payload);

                    alert("Score submitted successfully!");
                    submitBtn.textContent = "Score submitted!";
                    submitBtn.style.backgroundColor = "cyan";
                    submitBtn.style.color = "white";
                    submitBtn.style.cursor = "not-allowed";
                } catch (error) {
                    console.error("Error submitting score:", error);
                    alert("Failed to submit score. Please try again.");
                    submitBtn.disabled = false;
                    isSubmitting = false;
                    submitBtn.textContent = "Submit your suffe- I mean score";
                }
            }

            // Manual click (kept for UX)
            submitBtn.addEventListener("click", submitHellScore);

            // Automatic upload for logged‑in users
            submitHellScore();
        }

    }
    function nextQuestion() {
        if (currQuestion < allQuestions.length - 1) {
            currQuestion++;
            loadQues();
            document.querySelector(".correctanswer").innerHTML = "";
        } else {
            evalScreen();
        }
    }

    function showNotification(message, isSuccess = false) {
        const notification = document.getElementById("notification");
        notification.textContent = message;
        notification.classList.remove("hide", "success");
        if (isSuccess) {
            notification.classList.add("success");
        }
        setTimeout(() => {
            notification.classList.add("hide");
        }, 3000);
    }

    function checkAns() {
        // Validate quiz state
        if (!allQuestions || allQuestions.length === 0) {
            console.warn("No questions loaded");
            return;
        }
        
        if (currQuestion < 0 || currQuestion >= allQuestions.length) {
            console.warn("Invalid question index");
            return;
        }
        
        // Check if quiz has ended (evalScreen is shown)
        const evalDiv = document.querySelector(".evalscreen");
        if (evalDiv && evalDiv.style.display !== "none" && evalDiv.style.display !== "") {
            return; // Quiz has ended, don't process answers
        }
        
        const selectedAns = document.querySelector('input[name="answer"]:checked');
        if (selectedAns) {
            const answerValue = selectedAns.value;
            const correctAnswer = allQuestions[currQuestion].correct_answer;
            
            // Decode HTML entities for comparison (answers are stored with entities)
            function decodeHTMLEntities(text) {
                if (!text) return "";
                const txt = document.createElement("textarea");
                txt.innerHTML = text;
                return txt.value;
            }
            
            const decodedAnswerValue = decodeHTMLEntities(answerValue);
            const decodedCorrectAnswer = decodeHTMLEntities(correctAnswer);
            
            // Compare both decoded and original values to handle encoding differences
            if (decodedAnswerValue === decodedCorrectAnswer || answerValue === correctAnswer) {
                score++;
                // Clear the question timer before moving to next question
                if (window.answerTimerId) {
                    clearInterval(window.answerTimerId);
                }
                showNotification("Correct!", true);
                nextQuestion();
            } else {
                // Don't expose the correct answer
                showNotification("Wrong! You cannot progress with an incorrect answer.");
                return;
            }
        } else if (allQuestions.length > 0) {
            showNotification("Please select an answer.");
        }
    }


</script>

</html>
