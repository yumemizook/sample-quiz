<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <title>Home</title>
    <link rel="stylesheet" href="index.css" />
    <script src="https://kit.fontawesome.com/ced4c4a7f8.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <audio id="intro-audio" src="bgm/intro.mp3" style="display: none;"></audio>
    <div class="status" style="transition: opacity 1s;">
      <a login href="signin.html">Login</a>
      <a signup href="signup.html">Signup</a>
      <a logout class="hide" href="index.html">Log out</a>
      <div class="player-info hide" id="playerInfo">
        <div class="player-info-left">
          <span class="name"></span>
          <span class="player-level" id="playerLevel"></span>
        </div>
        <div class="player-avatar hide" id="playerAvatar">
          <img id="playerAvatarImg" src="" alt="Avatar" />
          <div class="player-avatar-placeholder"><i class="fas fa-user"></i></div>
        </div>
      </div>
    </div>
    <div id="profileBanner" class="profile-banner" style="display: none">
      <img id="bannerImage" src="" alt="Profile Banner" />
    </div>
    <div id="achievementNotification" class="notification hide"></div>
    <div class="container menu-container">
      <div class="menu-header">
        <h1 class="menu-title">Icy's Quiz Challenge</h1>
        <p class="menu-subtitle">
          TGM-style quiz game with timers, grades and more!
        </p>
      </div>

      <div class="mode-selection">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <h2 class="mode-selection-title" style="margin: 0;">Select Difficulty</h2>
        </div>
        <div class="mode-cards">
          <div class="mode-card" data-mode="easy" id="easyModeCard">
            <div class="mode-card-header">
              <span class="mode-icon"><i class="fas fa-seedling" style="color: #2ecc71;"></i></span>
              <h3 class="mode-name">Easy</h3>
            </div>
            <p class="mode-description" id="easyModeDescription">
              Perfect for beginners. Answer 30 easy questions as fast as you
              can!
            </p>
            <div class="mode-difficulty easy-diff">Beginner Friendly</div>
          </div>

          <div class="mode-card hide" data-mode="easy-race" id="easyRaceModeCard">
            <div class="mode-card-header">
              <span class="mode-icon"><i class="fas fa-seedling" style="color: #2ecc71;"></i></span>
              <h3 class="mode-name">Easy Race</h3>
            </div>
            <p class="mode-description">
              30 minute timer. 100 questions. Perfect for beginners.
            </p>
            <div class="mode-difficulty easy-diff">Medium Challenge</div>
          </div>

          <div class="mode-card hide" data-mode="hard-race" id="hardRaceModeCard">
            <div class="mode-card-header">
              <span class="mode-icon"><i class="fas fa-skull" style="color: #ff0000;"></i></span>
              <h3 class="mode-name">Hard Race</h3>
            </div>
            <p class="mode-description">
              4:30 total time limit. Are you up to the challenge?
            </p>
            <div class="mode-difficulty hell-diff">Difficult Challenge</div>
          </div>

          <div class="mode-card active" data-mode="normal">
            <div class="mode-card-header">
              <span class="mode-icon"><i class="fas fa-star" style="color: #ffd700;"></i></span>
              <h3 class="mode-name">Normal</h3>
            </div>
            <p class="mode-description">
              Answer questions to score points. The more you answer, the higher
              your score.
            </p>
            <div class="mode-difficulty normal-diff">Standard Challenge</div>
          </div>

          <div class="mode-card" data-mode="master" id="masterModeCard">
            <div class="mode-card-header">
              <span class="mode-icon"><i class="fas fa-crown" style="color: #ffd700;"></i></span>
              <h3 class="mode-name">Master</h3>
            </div>
            <p class="mode-description">
              Answer questions with a slowly shrinking time limit. Can you be
              the Grand Master?<br><small style="opacity: 0.7;"><i class="fas fa-lightbulb"></i> Click 5 times to toggle Race mode</small>
            </p>
            <div class="mode-difficulty master-diff">Expert Level</div>
          </div>

          <div class="mode-card hide" data-mode="master130" id="raceModeCard">
            <div class="mode-card-header" style="display: flex; justify-content: space-between; align-items: center;">
              <div style="display: flex; align-items: center; gap: 10px;">
                <span class="mode-icon"><i class="fas fa-bolt" style="color: #ffff00;"></i></span>
                <h3 class="mode-name" id="raceModeName">Race</h3>
              </div>
              <div style="display: flex; gap: 8px; align-items: center;">
                <button id="raceToggleMinus" class="mode-toggle-btn" style="width: 36px; height: 36px; border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.5); background: rgba(255, 255, 255, 0.1); color: white; font-size: 0.9em; cursor: pointer; transition: all 0.3s ease;" title="Previous race variant">
                  <i class="fas fa-minus"></i>
                </button>
                <button id="raceTogglePlus" class="mode-toggle-btn" style="width: 36px; height: 36px; border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.5); background: rgba(255, 255, 255, 0.1); color: white; font-size: 0.9em; cursor: pointer; transition: all 0.3s ease;" title="Next race variant">
                  <i class="fas fa-plus"></i>
                </button>
              </div>
            </div>
            <p class="mode-description" id="raceModeDescription">
              Race against time! 130 questions with a 7 minute time limit. Text elements fade randomly after question 100.<br><small style="opacity: 0.7;"><i class="fas fa-lightbulb"></i> Click 5 times to toggle Master mode</small>
            </p>
            <div class="mode-difficulty master-diff" id="raceModeDifficulty">Extreme Challenge</div>
          </div>

          <div class="mode-card" data-mode="hell" id="hellModeCard">
            <div class="mode-card-header" style="display: flex; justify-content: space-between; align-items: center;">
              <div style="display: flex; align-items: center; gap: 10px;">
                <span class="mode-icon"><i class="fas fa-fire" style="color: #ff6b35;"></i></span>
                <h3 class="mode-name" id="hellModeName">Hell</h3>
              </div>
              <div style="display: flex; gap: 8px; align-items: center;">
                <button id="hellToggleMinus" class="mode-toggle-btn" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.5); background: rgba(255, 255, 255, 0.1); color: white; font-size: 0.9em; cursor: pointer; transition: all 0.3s ease;" title="Previous hell variant">
                  <i class="fas fa-minus"></i>
                </button>
                <button id="hellTogglePlus" class="mode-toggle-btn" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.5); background: rgba(255, 255, 255, 0.1); color: white; font-size: 0.9em; cursor: pointer; transition: all 0.3s ease;" title="Next hell variant">
                  <i class="fas fa-plus"></i>
                </button>
              </div>
            </div>
            <p class="mode-description" id="hellModeDescription">
              Extremely difficult questions with inhumane time limits. Not for
              the faint of heart.
            </p>
            <div class="mode-difficulty hell-diff" id="hellModeDifficulty">Ultimate Challenge</div>
          </div>

          <div class="mode-card hide" data-mode="secret" id="secretModeCard">
            <div class="mode-card-header">
              <span class="mode-icon"><i class="fas fa-skull" style="color: #666666;"></i></span>
              <h3 class="mode-name">??????</h3>
            </div>
            <p class="mode-description">One step beyond Hell. No way back.</p>
            <div class="mode-difficulty hell-diff">Secret Mode</div>
          </div>
        </div>
      </div>

      <div class="mode-settings collapsed" id="modeSettings" style="display: none;">
        <h2 class="mode-settings-title">
          <span>Mode Settings</span>
          <button class="mode-settings-toggle" id="modeSettingsToggle" aria-label="Toggle settings">
            <span class="toggle-icon"><i class="fas fa-chevron-down"></i></span>
          </button>
        </h2>
        <div class="settings-container" id="settingsContainer">
          <div class="setting-item">
            <label class="setting-label">
              <span class="setting-text">Lives:</span>
              <div class="arrow-selector" data-setting="lives">
                <button class="arrow-btn arrow-left" aria-label="Previous option"><i class="fas fa-chevron-left"></i></button>
                <span class="selector-value" id="livesValue">30 Lives</span>
                <button class="arrow-btn arrow-right" aria-label="Next option"><i class="fas fa-chevron-right"></i></button>
                <select id="lives" class="setting-select-hidden" style="display: none;">
                  <option value="unlimited">Unlimited</option>
                  <option value="100">100 Lives</option>
                  <option value="30">30 Lives</option>
                  <option value="10">10 Lives</option>
                  <option value="5">5 Lives</option>
                  <option value="1">1 Life</option>
                </select>
              </div>
            </label>
            <span class="setting-description">Each wrong question deducts 1 life. Quiz ends when lives reach 0.</span>
          </div>
          <div class="setting-item">
            <label class="setting-label">
              <span class="setting-text">Time Multiplier:</span>
              <div class="slider-container">
                <input type="range" id="timeMultiplier" class="setting-slider" min="0.75" max="2" step="0.05" value="1" tabindex="0">
                <span class="slider-value" id="timeMultiplierValue">1.00x</span>
              </div>
            </label>
            <span class="setting-description">Adjusts timer countdown speed. Lower values = more time.</span>
          </div>
          <div class="setting-item">
            <label class="setting-label">
              <span class="setting-text">Vanish Mode:</span>
              <div class="arrow-selector" data-setting="fadingMode">
                <button class="arrow-btn arrow-left" aria-label="Previous option"><i class="fas fa-chevron-left"></i></button>
                <span class="selector-value" id="fadingModeValue">Off</span>
                <button class="arrow-btn arrow-right" aria-label="Next option"><i class="fas fa-chevron-right"></i></button>
                <select id="fadingMode" class="setting-select-hidden" style="display: none;">
                  <option value="off">Off</option>
                  <option value="2">2 seconds</option>
                  <option value="1">1 second</option>
                  <option value="0.5">0.5 seconds</option>
                </select>
              </div>
            </label>
            <span class="setting-description">Question elements randomly vanish one at a time at the selected interval</span>
          </div>
          <div class="setting-item">
            <label class="setting-label">
              <span class="setting-text">Start at Question:</span>
              <div class="arrow-selector" data-setting="startQuestion">
                <button class="arrow-btn arrow-left" aria-label="Previous option"><i class="fas fa-chevron-left"></i></button>
                <span class="selector-value" id="startQuestionValue">Question 1 (Start from beginning)</span>
                <button class="arrow-btn arrow-right" aria-label="Next option"><i class="fas fa-chevron-right"></i></button>
                <select id="startQuestion" class="setting-select-hidden" style="display: none;">
                  <option value="0">Question 1 (Start from beginning)</option>
                </select>
              </div>
            </label>
            <span class="setting-description">Start the quiz at a specific question (multiples of 10)</span>
          </div>
          <div class="setting-item">
            <label class="setting-label">
              <span class="setting-text">BGM Set:</span>
              <div class="arrow-selector" data-setting="bgmSet">
                <button class="arrow-btn arrow-left" aria-label="Previous option"><i class="fas fa-chevron-left"></i></button>
                <span class="selector-value" id="bgmSetValue">Default</span>
                <button class="arrow-btn arrow-right" aria-label="Next option"><i class="fas fa-chevron-right"></i></button>
                <select id="bgmSet" class="setting-select-hidden" style="display: none;">
                  <option value="default">Default</option>
                  <option value="alternative">Alternative</option>
                </select>
              </div>
            </label>
            <span class="setting-description">Choose which background music set to use for all modes</span>
          </div>
        </div>
      </div>

      <div class="menu-actions">
        <button class="menu-btn play-btn">
          <span class="btn-icon">â–¶</span>
          <span class="btn-text">Start Quiz</span>
        </button>
        <div class="secondary-actions">
          <button class="menu-btn secondary-btn hiscore">
            <span class="btn-icon"><i class="fas fa-trophy" style="color: #ffd700;"></i></span>
            <span class="btn-text">Leaderboards</span>
          </button>
          <button class="menu-btn secondary-btn stats">
            <span class="btn-icon"><i class="fas fa-chart-bar" style="color: #4a90e2;"></i></span>
            <span class="btn-text">Your Stats</span>
          </button>
          <button class="menu-btn secondary-btn wiki">
            <span class="btn-icon"><i class="fas fa-book" style="color: #9b59b6;"></i></span>
            <span class="btn-text">Wiki</span>
          </button>
          <button
            class="menu-btn secondary-btn tos"
            onclick="location.href='achievements.html'"
            title="View Achievements"
          >
            <span class="btn-icon"><i class="fas fa-trophy" style="color: #ffd700;"></i></span>
            <span class="btn-text">Achievements</span>
          </button>
          <button
            class="menu-btn secondary-btn privacy"
            onclick="location.href='privacy.html'"
          >
            <span class="btn-icon"><i class="fas fa-lock" style="color: #ff6b6b;"></i></span>
            <span class="btn-text">Privacy & Terms</span>
          </button>
          <button
            class="menu-btn secondary-btn settings"
            onclick="location.href='settings.html'"
          >
            <span class="btn-icon"><i class="fas fa-cog" style="color: #dbffff;"></i></span>
            <span class="btn-text">Settings</span>
          </button>
        </div>
      </div>
    </div>
    <div class="tips-container" id="tipsContainer">
      <div class="tips-header">
        <span class="tips-icon"><i class="fas fa-lightbulb"></i></span>
        <span class="tips-title">Tip</span>
      </div>
      <p class="tips-text" id="tipsText">Loading tips...</p>
    </div>

    <style>
      #intro-overlay .option:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: #b8f0e0;
      }

      #intro-overlay .option.selected {
        background: rgba(184, 240, 224, 0.2);
        border-color: #b8f0e0;
      }

      #intro-overlay .option input[type="radio"] {
        display: none;
      }

      @keyframes pulse {
        0%, 100% { opacity: 0.8; }
        50% { opacity: 1; }
      }

      @keyframes logoAnim {
        0% { transform: scale(1) rotate(0deg); filter: drop-shadow(0 0 10px rgba(219, 255, 255, 0.3)); }
        25% { transform: scale(1.05) rotate(1deg); filter: drop-shadow(0 0 20px rgba(184, 240, 224, 0.5)); }
        50% { transform: scale(1.1) rotate(-1deg); filter: drop-shadow(0 0 30px rgba(219, 255, 255, 0.7)); }
        75% { transform: scale(1.05) rotate(0.5deg); filter: drop-shadow(0 0 20px rgba(184, 240, 224, 0.5)); }
        100% { transform: scale(1) rotate(0deg); filter: drop-shadow(0 0 10px rgba(219, 255, 255, 0.3)); }
      }

      .logo-line1 {
        animation: logoLine1Anim 6s infinite alternate;
      }

      .logo-line2 {
        animation: logoLine2Anim 6s infinite alternate;
      }

      @keyframes logoLine1Anim {
        0% { transform: scale(1) rotate(-1deg); filter: drop-shadow(0 0 10px rgba(219, 255, 255, 0.5)); opacity: 1; }
        25% { transform: scale(1.05) rotate(0deg); filter: drop-shadow(0 0 15px rgba(219, 255, 255, 0.6)); opacity: 1; }
        50% { transform: scale(1.1) rotate(1deg); filter: drop-shadow(0 0 20px rgba(219, 255, 255, 0.8)); opacity: 0.3; }
        75% { transform: scale(1.05) rotate(0deg); filter: drop-shadow(0 0 15px rgba(219, 255, 255, 0.6)); opacity: 1; }
        100% { transform: scale(1) rotate(-1deg); filter: drop-shadow(0 0 10px rgba(219, 255, 255, 0.5)); opacity: 1; }
      }

      @keyframes logoLine2Anim {
        0% { transform: scale(1) rotate(1deg); filter: drop-shadow(0 0 10px rgba(184, 240, 224, 0.5)); opacity: 1; }
        20% { transform: scale(1.02) rotate(0.5deg); filter: drop-shadow(0 0 12px rgba(184, 240, 224, 0.6)); opacity: 1; }
        40% { transform: scale(1.05) rotate(-0.5deg); filter: drop-shadow(0 0 15px rgba(184, 240, 224, 0.7)); opacity: 0.5; }
        60% { transform: scale(1.1) rotate(0.5deg); filter: drop-shadow(0 0 20px rgba(184, 240, 224, 0.8)); opacity: 1; }
        80% { transform: scale(1.05) rotate(-0.5deg); filter: drop-shadow(0 0 15px rgba(184, 240, 224, 0.7)); opacity: 0.7; }
        100% { transform: scale(1) rotate(0deg); filter: drop-shadow(0 0 10px rgba(184, 240, 224, 0.5)); opacity: 1; }
      }

      .hint {
        animation: blink 3s infinite;
      }

      @keyframes blink {
        0%, 50% { opacity: 0.8; }
        51%, 100% { opacity: 0.3; }
      }

      @media (max-width: 768px) {
        #intro-overlay .logo {
          font-size: 3em;
        }

        #intro-overlay .demo-section {
          padding: 20px;
        }

        #intro-overlay .question-text {
          font-size: 1.2em;
        }

        #intro-overlay .options {
          grid-template-columns: 1fr;
        }

        #intro-overlay .videos-section {
          flex-direction: column;
          align-items: center;
        }

        #intro-overlay .video-placeholder {
          width: 200px;
          height: 120px;
        }

        #intro-overlay .hint {
          font-size: 1.2em;
        }
      }
    </style>

    <!-- Intro Screen Overlay -->
    <div id="intro-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%); color: #dbffff; font-family: 'Gill Sans MT', sans-serif; z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 40px; text-align: center; box-sizing: border-box; transition: opacity 1s, background 1s;">
      <!-- Info displays -->
      <div id="device-id" style="position: absolute; top: 20px; left: 20px; color: #dbffff; font-size: 1.1em; font-weight: bold; opacity: 0.8;">Device ID: Loading...</div>
      <div id="login-status" style="position: absolute; top: 20px; right: 20px; color: #dbffff; font-size: 1.1em; font-weight: bold; opacity: 0.8;">Login Status: Checking...</div>
      <div id="network-status" style="position: absolute; bottom: 20px; left: 20px; color: #dbffff; font-size: 1.1em; font-weight: bold; opacity: 0.8;">Network: Checking...</div>
      <div id="current-time" style="position: absolute; bottom: 20px; right: 20px; color: #dbffff; font-size: 1.1em; font-weight: bold; opacity: 0.8;">Time: Loading...</div>

      <!-- Now Loading text -->
      <div id="loading-text" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2em; color: #dbffff; z-index: 10;">Now Loading...</div>

      <!-- Presents text -->
      <div id="presents-text" style="position: absolute; top: 50%; left: -100%; transform: translate(-50%, -50%); font-size: 2em; font-weight: bold; color: white; opacity: 0; transition: left 2s ease-out, opacity 1s;">Colorbleed Neon presents...</div>

      <div class="intro-container" style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100%; max-width: 1200px;">
        <div id="logo-section" class="logo" style="font-size: 6em; font-weight: bold; text-align: center; line-height: 1.2; opacity: 0; visibility: visible; transition: opacity 1s;">
          <div class="logo-line1" style="position: relative; left: -100%; background: linear-gradient(135deg, #dbffff 0%, #b8f0e0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 0 0 20px rgba(219, 255, 255, 0.5), 0 0 40px rgba(219, 255, 255, 0.3); animation: logoLine1Anim 6s infinite alternate; transition: left 1s;">Icy's</div>
          <div class="logo-line2" style="position: relative; right: -100%; background: linear-gradient(135deg, #b8f0e0 0%, #dbffff 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 0 0 20px rgba(184, 240, 224, 0.5), 0 0 40px rgba(184, 240, 224, 0.3); animation: logoLine2Anim 6s infinite alternate; transition: right 1s;">Quiz Challenge</div>
        </div>

        <div id="demo-section" class="demo-section" style="background: rgba(0, 0, 0, 0.7); border-radius: 20px; padding: 30px; margin-bottom: 30px; border: 2px solid rgba(255, 255, 255, 0.1); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); max-width: 800px; width: 100%; opacity: 1; visibility: hidden; transition: opacity 1s;">
          <div class="sample-question" style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 20px; margin-bottom: 20px; opacity: 1; transition: opacity 1s;">
            <div class="question-text" style="font-size: 1.4em; margin-bottom: 15px; color: #dbffff;">Sample Question: What is the capital of France?</div>
            <div class="timer-display" style="font-size: 1.2em; color: #ff6b6b; margin-bottom: 10px; opacity: 0; transition: opacity 1s;">Timer: 10.00s</div>
            <div class="options" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
              <div class="option" style="background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 10px; padding: 10px; transition: all 0.3s; display: flex; align-items: center; gap: 10px;">
                <span class="option-label" style="color: #dbffff; font-size: 1.1em;">A) Paris</span>
              </div>
              <div class="option" style="background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 10px; padding: 10px; transition: all 0.3s; display: flex; align-items: center; gap: 10px;">
                <span class="option-label" style="color: #dbffff; font-size: 1.1em;">B) London</span>
              </div>
              <div class="option" style="background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 10px; padding: 10px; transition: all 0.3s; display: flex; align-items: center; gap: 10px;">
                <span class="option-label" style="color: #dbffff; font-size: 1.1em;">C) Berlin</span>
              </div>
              <div class="option" style="background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 10px; padding: 10px; transition: all 0.3s; display: flex; align-items: center; gap: 10px;">
                <span class="option-label" style="color: #dbffff; font-size: 1.1em;">D) Madrid</span>
              </div>
            </div>
          </div>
          <div class="demo-instruction-text" style="font-size: 1.2em; color: #b8f0e0; font-weight: bold; text-align: center; opacity: 0; transition: opacity 1s;"></div>
        </div>

        <div id="videos-section" class="videos-section" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; visibility: hidden; transition: opacity 1s;">
          <video id="video1" autoplay muted loop style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
            <source src="bgm/intro.mp3" type="video/mp4">
            Your browser does not support the video tag.
          </video>
          <video id="video2" autoplay muted loop style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; display: none;">
            <source src="bgm/intro.mp3" type="video/mp4">
            Your browser does not support the video tag.
          </video>
        </div>

        <div class="hint" style="font-size: 1.5em; color: #dbffff; opacity: 0.8; animation: pulse 2s infinite;">Press any key to begin</div>
      </div>
    </div>

    <script>
      // Hide loading text once DOM is loaded
      document.getElementById('loading-text').style.display = 'none';

      function selectIntroOption(optionElement) {
        // Remove selected class from all options
        document.querySelectorAll('#intro-overlay .option').forEach(opt => {
          opt.classList.remove('selected');
        });
        // Add selected class to clicked option
        optionElement.classList.add('selected');
        // Check the radio button
        const radio = optionElement.querySelector('input[type="radio"]');
        if (radio) {
          radio.checked = true;
        }
      }

      // Function to hide intro overlay
      function hideIntro() {
        const overlay = document.getElementById('intro-overlay');
        if (overlay) {
          overlay.style.opacity = '0';
          setTimeout(() => {
            overlay.style.display = 'none';
          }, 1000); // Match transition time
        }
        // Stop BGM and cycling
        introAudio.pause();
        introAudio.currentTime = 0;
        if (cycleInterval) clearInterval(cycleInterval);
        introAudio.removeEventListener('ended', endedHandler);
        // Mark as shown
        sessionStorage.setItem('introShown', 'true');
        // Show navbar and main content
        const statusDiv = document.querySelector('.status');
        if (statusDiv) {
          statusDiv.style.opacity = '1';
        }
        const menuContainer = document.querySelector('.menu-container');
        if (menuContainer) {
          menuContainer.style.display = 'block';
        }
        const tipsContainer = document.getElementById('tipsContainer');
        if (tipsContainer) {
          tipsContainer.style.display = 'block';
        }
        // Banner display is handled by updateLoginStatus based on login state
        const achievementNotification = document.getElementById('achievementNotification');
        if (achievementNotification) {
          achievementNotification.style.display = 'block';
        }
      }

      // Listen for any key press to hide intro
      document.addEventListener('keydown', function(event) {
        if (!audioPlayed) {
          introAudio.currentTime = 0;
          introAudio.muted = false;
          introAudio.volume = 0.5;
          introAudio.play();
          audioPlayed = true;
        }
        hideIntro();
      });

      // Also listen for click/touch to hide, but not on interactive elements
      document.addEventListener('click', function(event) {
        if (!event.target.closest('#intro-overlay .option')) {
          if (!audioPlayed) {
            introAudio.currentTime = 0;
            introAudio.muted = false;
            introAudio.volume = 0.5;
            introAudio.play();
            audioPlayed = true;
          }
          hideIntro();
        }
      });

      // BGM for logo
      const introAudio = document.getElementById('intro-audio');
      // introAudio.loop = true; // Removed loop
      let audioPlayed = false;

      // Debug logging for autoplay bypass verification
      console.log('Intro audio element:', introAudio);
      if (introAudio) {
        console.log('Audio src:', introAudio.src);
        console.log('Audio readyState:', introAudio.readyState);
        introAudio.addEventListener('canplay', () => console.log('Audio can play'));
        introAudio.addEventListener('play', () => console.log('Audio started playing'));
        introAudio.addEventListener('error', (e) => console.log('Audio error:', e));
      }

      // Cycling between sections
      const sections = ['logo-section', 'demo-section', 'videos-section'];
      let currentSectionIndex = 0;
      let firstLogo = true;
      let logoIntroStarted = false;

      // Change text color to white
      const presentsText = document.getElementById('presents-text');
      if (presentsText) {
        presentsText.style.color = 'white';
      }

      function showSection(index) {
        // Hide all sections
        sections.forEach(id => {
          const el = document.getElementById(id);
          if (el) {
            el.style.opacity = '0';
            el.style.visibility = 'hidden';
          }
        });
        // Show current section
        const currentEl = document.getElementById(sections[index]);
        if (currentEl) {
          currentEl.style.opacity = '1';
          currentEl.style.visibility = 'visible';
        }

        // Special handling for logo section
        if (sections[index] === 'logo-section') {
          // Always start intro sequence
          startLogoIntro();
          introAudio.currentTime = 0;
          introAudio.play().catch(e => console.log('Audio play failed:', e));
        } else if (sections[index] === 'demo-section') {
          // Start demo sequence
          startDemoSequence();
          introAudio.pause();
        } else {
          introAudio.pause();
        }

        // For videos, randomly show one
        if (sections[index] === 'videos-section') {
          const video1 = document.getElementById('video1');
          const video2 = document.getElementById('video2');
          if (video1 && video2) {
            const showFirst = Math.random() < 0.5;
            video1.style.display = showFirst ? 'flex' : 'none';
            video2.style.display = showFirst ? 'none' : 'flex';
          }
        }
      }

      function startLogoIntro() {
        if (logoIntroStarted) return;
        logoIntroStarted = true;

        const overlay = document.getElementById('intro-overlay');
        const presentsText = document.getElementById('presents-text');
        const logo = document.getElementById('logo-section');

        // Ensure logo is hidden and lines are off-screen
        logo.style.opacity = '0';
        const line1 = document.querySelector('.logo-line1');
        const line2 = document.querySelector('.logo-line2');
        if (line1) line1.style.left = '-100%';
        if (line2) line2.style.right = '-100%';

        // Start with black background
        overlay.style.background = 'black';
        overlay.style.transition = 'background 0.5s'; // Quick transition to white

        // Show presents text
        presentsText.style.left = '50%';
        presentsText.style.opacity = '1';

        // After 3 seconds, change to white background, hide presents
        setTimeout(() => {
          overlay.style.background = 'white';
          presentsText.style.opacity = '0';
        }, 3000);

        // After 3.5 seconds, change transition to slower for gradient
        setTimeout(() => {
          overlay.style.transition = 'background 2s';
        }, 3500);

        // After 4 seconds, back to normal background, show logo and animate lines
        setTimeout(() => {
          overlay.style.background = 'linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%)';
          logo.style.opacity = '1';
          // Animate lines in
          const line1 = document.querySelector('.logo-line1');
          const line2 = document.querySelector('.logo-line2');
          if (line1) line1.style.left = '0';
          if (line2) line2.style.right = '0';
          firstLogo = false;
        }, 4000);

        // Try to autoplay muted, fallback to play on user interaction
        console.log('Starting logo intro, attempting autoplay');
        introAudio.muted = true;
        introAudio.currentTime = 0;
        introAudio.play().then(() => {
          audioPlayed = true;
          setTimeout(() => {
            introAudio.muted = false;
            introAudio.volume = 0.5;
            console.log('Audio unmuted and volume set to 50%');
          }, 100);
        }).catch(e => {
          console.log('Autoplay failed, will play on user interaction:', e);
        });
      }

      function startDemoSequence() {
        const timer = document.querySelector('#demo-section .timer-display');
        const options = document.querySelectorAll('#demo-section .option');
        const instructionText = document.querySelector('#demo-section .demo-instruction-text');

        // Reset all
        timer.style.opacity = '0';
        instructionText.style.opacity = '0';
        options.forEach(opt => {
          opt.style.borderColor = 'rgba(255, 255, 255, 0.2)';
          opt.style.background = 'rgba(255, 255, 255, 0.1)';
        });

        // Sequence
        setTimeout(() => {
          instructionText.textContent = 'Answer questions to progress.';
          instructionText.style.opacity = '1';
        }, 1000); // 1s: show first instruction

        setTimeout(() => {
          timer.style.opacity = '1';
          instructionText.textContent = 'Be careful! Each question has a time limit!';
        }, 8000); // 8s: show timer and second instruction

        setTimeout(() => {
          instructionText.textContent = 'You need to answer correctly to progress...';
          // First show wrong answer
          options[1].style.borderColor = '#e74c3c'; // London wrong
          options[1].style.background = 'rgba(231, 76, 60, 0.2)';
          setTimeout(() => {
            options[1].style.borderColor = 'rgba(255, 255, 255, 0.2)';
            options[1].style.background = 'rgba(255, 255, 255, 0.1)';
            // Then show correct
            options[0].style.borderColor = '#2ecc71'; // Paris correct
            options[0].style.background = 'rgba(46, 204, 113, 0.2)';
          }, 2000);
        }, 16000); // 16s: third instruction, show wrong then correct

        setTimeout(() => {
          instructionText.textContent = 'There are grades: Answer questions and climb up the grades';
        }, 24000); // 24s: fourth instruction

        setTimeout(() => {
          instructionText.textContent = 'You have one goal: to be the Grand Master.';
        }, 32000); // 32s: fifth instruction
      }

      function cycleSections() {
        currentSectionIndex = (currentSectionIndex + 1) % sections.length;
        logoIntroStarted = false; // Reset for next logo intro
        showSection(currentSectionIndex);
      }

      // Start cycling every 45 seconds or when audio ends
      const cycleInterval = setInterval(cycleSections, 45000);
      const endedHandler = () => cycleSections();
      introAudio.addEventListener('ended', endedHandler);

      // Only show intro if not shown in this session
      if (!sessionStorage.getItem('introShown')) {
        // Initially show logo
        showSection(0);

        // Hide navbar and main content when intro is shown
        const statusDiv = document.querySelector('.status');
        if (statusDiv) {
          statusDiv.style.opacity = '0';
        }
        const menuContainer = document.querySelector('.menu-container');
        if (menuContainer) {
          menuContainer.style.display = 'none';
        }
        const tipsContainer = document.getElementById('tipsContainer');
        if (tipsContainer) {
          tipsContainer.style.display = 'none';
        }
        const profileBanner = document.getElementById('profileBanner');
        if (profileBanner) {
          profileBanner.style.display = 'none';
        }
        const achievementNotification = document.getElementById('achievementNotification');
        if (achievementNotification) {
          achievementNotification.style.display = 'none';
        }
      } else {
        // Hide intro overlay completely
        const overlay = document.getElementById('intro-overlay');
        if (overlay) {
          overlay.style.display = 'none';
        }
      }

      // Device ID generation
      async function generateDeviceId() {
        let deviceId = localStorage.getItem('deviceId');
        if (!deviceId) {
          try {
            // Fetch IP from ipify
            const response = await fetch('https://api.ipify.org?format=json');
            const data = await response.json();
            const ip = data.ip;

            // Convert IP to decimal
            const ipDecimal = ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet), 0);

            // Get Unix timestamp for first login
            const firstLogin = Math.floor(Date.now() / 1000);

            // Combine: decimal IP + Unix timestamp, take first 16 digits
            deviceId = (ipDecimal.toString() + firstLogin.toString()).substr(0, 16);
            localStorage.setItem('deviceId', deviceId);
          } catch (error) {
            console.error('Error fetching IP:', error);
            // Fallback
            deviceId = 'fallback' + Math.random().toString().substr(2, 8);
            localStorage.setItem('deviceId', deviceId);
          }
        }
        return deviceId;
      }

      // Update device ID display
      const deviceIdEl = document.getElementById('device-id');
      if (deviceIdEl) {
        generateDeviceId().then(id => {
          deviceIdEl.textContent = 'Device ID: ' + id;
        });
      }

      // Login status
      function updateLoginStatus() {
        const loginStatusEl = document.getElementById('login-status');
        const profileBanner = document.getElementById('profileBanner');
        if (!loginStatusEl) return;
      
        const playerInfo = document.getElementById('playerInfo');
        const nameEl = document.querySelector('.status .name');
        if (playerInfo && !playerInfo.classList.contains('hide') && nameEl && nameEl.textContent) {
          loginStatusEl.textContent = 'Logged in as ' + nameEl.textContent;
          if (profileBanner) profileBanner.style.display = 'block';
        } else {
          loginStatusEl.textContent = 'Logged out';
          if (profileBanner) profileBanner.style.display = 'none';
        }
      }
      updateLoginStatus();
      // Update login status periodically
      setInterval(updateLoginStatus, 5000);

      // Current time
      function updateTime() {
        const timeEl = document.getElementById('current-time');
        if (timeEl) {
          const now = new Date();
          timeEl.textContent = now.toLocaleString();
        }
      }
      updateTime();
      setInterval(updateTime, 1000);

      // Network status
      function updateNetworkStatus() {
        const networkEl = document.getElementById('network-status');
        if (networkEl) {
          networkEl.textContent = 'Network: ' + (navigator.onLine ? 'Online' : 'Offline');
        }
      }
      updateNetworkStatus();
      window.addEventListener('online', updateNetworkStatus);
      window.addEventListener('offline', updateNetworkStatus);
    </script>
  </body>
  <script type="module" src="firebase.js"></script>
  <script type="module" src="menuNavigation.js"></script>
  <script type="module" src="hm.js"></script>
  <script type="module" src="loadBackground.js"></script>
  <script type="module" src="loadTheme.js"></script>
  <script>
    // Mode settings handler
    (function() {
      const modeSettings = document.getElementById("modeSettings");
      const fadingMode = document.getElementById("fadingMode");
      const startQuestion = document.getElementById("startQuestion");
      const timeMultiplier = document.getElementById("timeMultiplier");
      const timeMultiplierValue = document.getElementById("timeMultiplierValue");
      
      // Update time multiplier display
      if (timeMultiplier && timeMultiplierValue) {
        timeMultiplier.addEventListener("input", () => {
          const value = parseFloat(timeMultiplier.value);
          timeMultiplierValue.textContent = value.toFixed(2) + "x";
        });
        // Initialize display
        const initialValue = parseFloat(timeMultiplier.value);
        timeMultiplierValue.textContent = initialValue.toFixed(2) + "x";
      }
      
      // Mode question counts
      const modeQuestionCounts = {
        easy: 30,
        normal: 100,
        master: 100,
        master130: 130,
        hell: 200,
        secret: 200
      };
      
      // Update start question options based on selected mode
      function updateStartQuestionOptions(mode) {
        const questionCount = modeQuestionCounts[mode] || 100;
        const startQuestionSelect = document.getElementById("startQuestion");
        const startQuestionValue = document.getElementById("startQuestionValue");
        
        if (startQuestionSelect) {
          startQuestionSelect.innerHTML = '<option value="0">Question 1 (Start from beginning)</option>';
          
          // Add options for multiples of 10
          // For race mode, skip 100, 110, 120 to avoid duplicates (they'll be added as 101, 111, 121)
          const skipIndices = mode === "master130" ? [100, 110, 120] : [];
          for (let i = 10; i < questionCount; i += 10) {
            if (!skipIndices.includes(i)) {
              const option = document.createElement("option");
              option.value = i;
              option.textContent = `Question ${i + 1}`;
              startQuestionSelect.appendChild(option);
            }
          }
          
          // For race mode (master130), add specific questions 101, 111, 121
          if (mode === "master130") {
            const specialQuestions = [100, 110, 120]; // Indices for questions 101, 111, 121
            specialQuestions.forEach(index => {
              if (index < questionCount) {
                const option = document.createElement("option");
                option.value = index;
                option.textContent = `Question ${index + 1}`;
                startQuestionSelect.appendChild(option);
              }
            });
          }
          
          // Update display value
          if (startQuestionValue) {
            const selectedOption = startQuestionSelect.options[startQuestionSelect.selectedIndex];
            startQuestionValue.textContent = selectedOption.textContent;
          }
          
          // Update modifier icons when start question changes
          if (typeof updateModifierIcons === 'function') {
            updateModifierIcons();
          }
        }
      }
      
      // Initialize arrow selector values
      function initializeArrowSelectors() {
        const livesSelect = document.getElementById("lives");
        const livesValue = document.getElementById("livesValue");
        const fadingModeSelect = document.getElementById("fadingMode");
        const fadingModeValue = document.getElementById("fadingModeValue");
        const startQuestionSelect = document.getElementById("startQuestion");
        const startQuestionValue = document.getElementById("startQuestionValue");
        
        if (livesSelect && livesValue) {
          // Set default to "Unlimited" if not already set
          if (livesSelect.selectedIndex === -1 || livesSelect.value === "") {
            livesSelect.selectedIndex = 0; // Select "Unlimited"
          }
          const selectedOption = livesSelect.options[livesSelect.selectedIndex];
          livesValue.textContent = selectedOption.textContent;
        }
        
        if (fadingModeSelect && fadingModeValue) {
          const selectedOption = fadingModeSelect.options[fadingModeSelect.selectedIndex];
          fadingModeValue.textContent = selectedOption.textContent;
        }
        
        if (startQuestionSelect && startQuestionValue) {
          const selectedOption = startQuestionSelect.options[startQuestionSelect.selectedIndex];
          startQuestionValue.textContent = selectedOption.textContent;
        }

        const bgmSetSelect = document.getElementById("bgmSet");
        const bgmSetValue = document.getElementById("bgmSetValue");

        if (bgmSetSelect && bgmSetValue) {
          const selectedOption = bgmSetSelect.options[bgmSetSelect.selectedIndex];
          bgmSetValue.textContent = selectedOption.textContent;
        }
      }
      
      // Cycle through select options
      function cycleSelectOption(select, direction, valueElement) {
        const options = Array.from(select.options);
        const currentIndex = select.selectedIndex;
        let newIndex;
        
        if (direction === 'right') {
          newIndex = (currentIndex + 1) % options.length;
        } else {
          newIndex = (currentIndex - 1 + options.length) % options.length;
        }
        
        select.selectedIndex = newIndex;
        const selectedOption = select.options[newIndex];
        
        if (valueElement) {
          valueElement.textContent = selectedOption.textContent;
        }
        
        select.dispatchEvent(new Event('change', { bubbles: true }));
      }
      
      // Setup arrow button handlers
      function setupArrowSelectors() {
        // Lives selector
        const livesSelector = document.querySelector('[data-setting="lives"]');
        if (livesSelector) {
          const leftBtn = livesSelector.querySelector('.arrow-left');
          const rightBtn = livesSelector.querySelector('.arrow-right');
          const livesSelect = document.getElementById("lives");
          const livesValue = document.getElementById("livesValue");
          
          if (leftBtn) {
            leftBtn.addEventListener("click", () => {
              cycleSelectOption(livesSelect, 'left', livesValue);
            });
          }
          if (rightBtn) {
            rightBtn.addEventListener("click", () => {
              cycleSelectOption(livesSelect, 'right', livesValue);
            });
          }
        }
        
        // Fading Mode selector
        const fadingModeSelector = document.querySelector('[data-setting="fadingMode"]');
        if (fadingModeSelector) {
          const leftBtn = fadingModeSelector.querySelector('.arrow-left');
          const rightBtn = fadingModeSelector.querySelector('.arrow-right');
          const fadingModeSelect = document.getElementById("fadingMode");
          const fadingModeValue = document.getElementById("fadingModeValue");
          
          if (leftBtn) {
            leftBtn.addEventListener("click", () => {
              cycleSelectOption(fadingModeSelect, 'left', fadingModeValue);
            });
          }
          if (rightBtn) {
            rightBtn.addEventListener("click", () => {
              cycleSelectOption(fadingModeSelect, 'right', fadingModeValue);
            });
          }
        }
        
        // Start Question selector
        const startQuestionSelector = document.querySelector('[data-setting="startQuestion"]');
        if (startQuestionSelector) {
          const leftBtn = startQuestionSelector.querySelector('.arrow-left');
          const rightBtn = startQuestionSelector.querySelector('.arrow-right');
          const startQuestionSelect = document.getElementById("startQuestion");
          const startQuestionValue = document.getElementById("startQuestionValue");

          if (leftBtn) {
            leftBtn.addEventListener("click", () => {
              cycleSelectOption(startQuestionSelect, 'left', startQuestionValue);
            });
          }
          if (rightBtn) {
            rightBtn.addEventListener("click", () => {
              cycleSelectOption(startQuestionSelect, 'right', startQuestionValue);
            });
          }
        }

        // BGM Set selector
        const bgmSetSelector = document.querySelector('[data-setting="bgmSet"]');
        if (bgmSetSelector) {
          const leftBtn = bgmSetSelector.querySelector('.arrow-left');
          const rightBtn = bgmSetSelector.querySelector('.arrow-right');
          const bgmSetSelect = document.getElementById("bgmSet");
          const bgmSetValue = document.getElementById("bgmSetValue");

          if (leftBtn) {
            leftBtn.addEventListener("click", () => {
              cycleSelectOption(bgmSetSelect, 'left', bgmSetValue);
            });
          }
          if (rightBtn) {
            rightBtn.addEventListener("click", () => {
              cycleSelectOption(bgmSetSelect, 'right', bgmSetValue);
            });
          }
        }
      }
      
      // Show/hide settings when mode is selected
      function handleModeSelection(mode) {
        if (mode && mode !== "secret") {
          modeSettings.style.display = "block";
          updateStartQuestionOptions(mode);
          // Re-initialize arrow selectors after mode change
          setTimeout(() => {
            initializeArrowSelectors();
            // Update settings items in navigation system
            if (window.updateSettingsItems) {
              window.updateSettingsItems();
            }
          }, 0);
        } else {
          modeSettings.style.display = "none";
          // Update settings items in navigation system
          if (window.updateSettingsItems) {
            window.updateSettingsItems();
          }
        }
      }
      
      // Race variants toggle (inside race mode card)
      const buildRaceVariants = () => {
        const variants = [
          {
            id: "easy-race",
            name: "Race (Easy)",
            description: "30 minute timer. 100 questions. May speed be in your hands.",
            difficulty: "Timed Challenge",
            icon: 'seedling',
            color: '#2ecc71'
          },
          {
            id: "master130",
            name: "Race",
            description: "Race against time! 130 questions with a 7 minute time limit. Text elements fade randomly after question 100.",
            difficulty: "Extreme Challenge",
            icon: 'bolt',
            color: '#ffff00'
          }
        ];
        // Only include hard race if player has completed race at least once
        if (window.hasCompletedRace) {
          variants.push({
            id: "hard-race",
            name: "Race (Hard)",
            description: "4:30 total time. Are you up to the ultimate challenge?",
            difficulty: "Extreme Challenge",
            icon: 'skull',
            color: '#ff0000'
          });
        }
        return variants;
      };
      let raceVariants = buildRaceVariants();
      let raceVariantIndex = 1; // start at standard race
      const raceModeCard = document.getElementById("raceModeCard");
      const raceModeName = document.getElementById("raceModeName");
      const raceModeDescription = document.getElementById("raceModeDescription");
      const raceModeDifficulty = document.getElementById("raceModeDifficulty");
      const raceToggleMinus = document.getElementById("raceToggleMinus");
      const raceTogglePlus = document.getElementById("raceTogglePlus");
      const easyRaceModeCard = document.getElementById("easyRaceModeCard");
      const hardRaceModeCard = document.getElementById("hardRaceModeCard");
      const easyModeCard = document.getElementById("easyModeCard");
      const hellModeCard = document.getElementById("hellModeCard");
      const hellModeName = document.getElementById("hellModeName");
      const hellModeDescription = document.getElementById("hellModeDescription");
      const hellModeDifficulty = document.getElementById("hellModeDifficulty");
      const hellToggleMinus = document.getElementById("hellToggleMinus");
      const hellTogglePlus = document.getElementById("hellTogglePlus");
      let selectedMode = "normal";

      function updateModeStyling(mode) {
        document.querySelectorAll(".mode-card").forEach(card => {
          const isSelected = card.getAttribute("data-mode") === mode;
          card.classList.toggle("active", isSelected);
        });
      }
      
      // Always hide separate easy/hard race cards; race card handles variants
      if (easyRaceModeCard) easyRaceModeCard.classList.add("hide");
      if (hardRaceModeCard) hardRaceModeCard.classList.add("hide");
      
      function applyRaceVariant(index) {
        // Rebuild variants in case eligibility changed
        raceVariants = buildRaceVariants();
        raceVariantIndex = ((index % raceVariants.length) + raceVariants.length) % raceVariants.length;
        const variant = raceVariants[raceVariantIndex];
        if (!raceModeCard || !variant) return;
        raceModeCard.setAttribute("data-mode", variant.id);
        if (raceModeName) raceModeName.textContent = variant.name;
        if (raceModeDescription) raceModeDescription.innerHTML = `${variant.description}<br><small style="opacity: 0.7;"><i class="fas fa-lightbulb"></i> Click 5 times to toggle Master mode</small>`;
        if (raceModeDifficulty) raceModeDifficulty.textContent = variant.difficulty;

        // Update mode icon
        const raceModeIcon = raceModeCard.querySelector('.mode-icon i');
        if (raceModeIcon && variant.icon) {
          raceModeIcon.className = `fas fa-${variant.icon}`;
          raceModeIcon.style.color = variant.color;
        }

        // If race card is active, update selected mode and styling
        if (raceModeCard.classList.contains("active")) {
          selectedMode = variant.id;
          updateModeStyling(selectedMode);
          handleModeSelection(selectedMode);
        }
      }
      
      if (raceToggleMinus) {
        raceToggleMinus.addEventListener("click", (e) => {
          e.stopPropagation();
          applyRaceVariant(raceVariantIndex - 1);
        });
      }
      if (raceTogglePlus) {
        raceTogglePlus.addEventListener("click", (e) => {
          e.stopPropagation();
          applyRaceVariant(raceVariantIndex + 1);
        });
      }
      
      // Initialize race variant
      applyRaceVariant(raceVariantIndex);

      // Listen for race eligibility updates (from hm.js after score fetch)
      window.addEventListener("race-eligibility", (e) => {
        const unlocked = !!(e.detail && e.detail.hasCompletedRace);
        window.hasCompletedRace = unlocked;
        // Re-apply variant to respect new eligibility (clamp index)
        raceVariants = buildRaceVariants();
        if (raceVariantIndex >= raceVariants.length) {
          raceVariantIndex = raceVariants.length - 1;
        }
        applyRaceVariant(raceVariantIndex);
      });
      
      // 5-click toggle for master/race mode cards
      let masterCardClickCount = 0;
      let raceCardClickCount = 0;
      let masterCardClickTimer = null;
      let raceCardClickTimer = null;
      const masterModeCard = document.getElementById("masterModeCard");
      
      // Master card 5-click toggle
      if (masterModeCard) {
        masterModeCard.addEventListener("click", (e) => {
          masterCardClickCount++;
          raceCardClickCount = 0; // Reset race card counter
          if (raceCardClickTimer) {
            clearTimeout(raceCardClickTimer);
            raceCardClickTimer = null;
          }
          
          // Clear previous timer
          if (masterCardClickTimer) {
            clearTimeout(masterCardClickTimer);
          }
          
          // Check if clicked 5 times within 2 seconds
          masterCardClickTimer = setTimeout(() => {
            if (masterCardClickCount >= 5) {
              masterModeCard.classList.add("hide");
              raceModeCard.classList.remove("hide");
              // Update mode selection to race mode
              handleModeSelection("master130");
            }
            masterCardClickCount = 0;
            masterCardClickTimer = null;
          }, 2000);
        });
      }
      
      // Race card 5-click toggle
      if (raceModeCard) {
        raceModeCard.addEventListener("click", (e) => {
          raceCardClickCount++;
          masterCardClickCount = 0; // Reset master card counter
          if (masterCardClickTimer) {
            clearTimeout(masterCardClickTimer);
            masterCardClickTimer = null;
          }
          
          // Clear previous timer
          if (raceCardClickTimer) {
            clearTimeout(raceCardClickTimer);
          }
          
          // Check if clicked 5 times within 2 seconds
          raceCardClickTimer = setTimeout(() => {
            if (raceCardClickCount >= 5) {
              raceModeCard.classList.add("hide");
              masterModeCard.classList.remove("hide");
              // Update mode selection to master mode
              handleModeSelection("master");
            }
            raceCardClickCount = 0;
            raceCardClickTimer = null;
          }, 2000);
        });
      }
      
      // Listen for mode card clicks
      document.querySelectorAll(".mode-card").forEach(card => {
        card.addEventListener("click", () => {
          const mode = card.getAttribute("data-mode");
          selectedMode = mode;
          updateModeStyling(selectedMode);
          handleModeSelection(mode);
        });
      });

      // Hell variants toggle (Hell / Death)
      const hellVariants = [
        {
          id: "hell",
          name: "Hell",
          description: "Extremely difficult questions with inhumane time limits. Not for the faint of heart.",
          difficulty: "Ultimate Challenge",
          icon: 'fire',
          color: '#ff6b35'
        },
        {
          id: "death",
          name: "Death",
          description: "100-question gauntlet. Easier than Hell mode.",
          difficulty: "Step-up Challenge",
          icon: 'skull',
          color: '#666666'
        }
      ];
      let hellVariantIndex = 0;
      function applyHellVariant(index) {
        hellVariantIndex = ((index % hellVariants.length) + hellVariants.length) % hellVariants.length;
        const variant = hellVariants[hellVariantIndex];
        if (!hellModeCard || !variant) return;
        hellModeCard.setAttribute("data-mode", variant.id);
        if (hellModeName) hellModeName.textContent = variant.name;
        if (hellModeDescription) hellModeDescription.textContent = variant.description;
        if (hellModeDifficulty) hellModeDifficulty.textContent = variant.difficulty;
        if (hellModeCard.classList.contains("active")) {
          selectedMode = variant.id;
          updateModeStyling(selectedMode);
          handleModeSelection(selectedMode);
        }
      }
      if (hellToggleMinus) {
        hellToggleMinus.addEventListener("click", (e) => {
          e.stopPropagation();
          applyHellVariant(hellVariantIndex - 1);
        });
      }
      if (hellTogglePlus) {
        hellTogglePlus.addEventListener("click", (e) => {
          e.stopPropagation();
          applyHellVariant(hellVariantIndex + 1);
        });
      }
      applyHellVariant(hellVariantIndex);
      
      // Function to update modifier icons on all mode cards
      function updateModifierIcons() {
        const livesValue = document.getElementById("lives")?.value || "unlimited";
        const timeMultiplier = parseFloat(document.getElementById("timeMultiplier")?.value || "1");
        const fadingMode = document.getElementById("fadingMode")?.value || "off";
        const startQuestion = parseInt(document.getElementById("startQuestion")?.value || "0");
        
        // Get all mode modifier containers
        const modifierContainers = document.querySelectorAll(".mode-modifiers");
        
        modifierContainers.forEach(container => {
          const mode = container.getAttribute("data-mode");
          // Only show modifiers for modes that support them
          if (["easy", "normal", "master", "master130", "hell"].includes(mode)) {
            container.innerHTML = "";
            
            // Lives icon (only show if not unlimited)
            if (livesValue !== "unlimited") {
              const livesIcon = document.createElement("div");
              livesIcon.className = "modifier-icon";
              livesIcon.title = `${livesValue} Lives`;
              livesIcon.textContent = livesValue === "100" ? "100" : livesValue;
              container.appendChild(livesIcon);
            }
            
            // Start question icon (only if not starting from beginning)
            if (startQuestion > 0) {
              const startIcon = document.createElement("div");
              startIcon.className = "modifier-icon";
              startIcon.title = `Start at Question ${startQuestion + 1}`;
              startIcon.textContent = `Q${startQuestion + 1}`;
              container.appendChild(startIcon);
            }
            
            // Time multiplier icon (only if not 1x)
            if (timeMultiplier !== 1) {
              const timeIcon = document.createElement("div");
              timeIcon.className = "modifier-icon";
              timeIcon.title = `Time Multiplier: ${timeMultiplier.toFixed(2)}x`;
              timeIcon.textContent = `${timeMultiplier.toFixed(2)}x`;
              container.appendChild(timeIcon);
            }
            
            // Fading mode icon (only if enabled)
            if (fadingMode !== "off") {
              const fadeIcon = document.createElement("div");
              fadeIcon.className = "modifier-icon";
              fadeIcon.title = `Vanish Mode: every ${fadingMode}s`;
              fadeIcon.textContent = `F${fadingMode}s`;
              container.appendChild(fadeIcon);
            }
          }
        });
      }
      
      // Initialize with default mode (normal)
      handleModeSelection("normal");
      updateModeStyling("normal");
      
      // Initialize arrow selectors
      initializeArrowSelectors();
      setupArrowSelectors();
      
      // Update modifier icons initially
      updateModifierIcons();
      
      // Update modifier icons whenever modifiers change
      const livesSelect = document.getElementById("lives");
      const timeMultiplierSlider = document.getElementById("timeMultiplier");
      const fadingModeSelect = document.getElementById("fadingMode");
      const startQuestionSelect = document.getElementById("startQuestion");
      
      if (livesSelect) {
        livesSelect.addEventListener("change", updateModifierIcons);
      }
      if (timeMultiplierSlider) {
        timeMultiplierSlider.addEventListener("input", updateModifierIcons);
      }
      if (fadingModeSelect) {
        fadingModeSelect.addEventListener("change", updateModifierIcons);
      }
      if (startQuestionSelect) {
        startQuestionSelect.addEventListener("change", updateModifierIcons);
      }
      
      // Also update when arrow selectors change (they update the hidden selects)
      document.querySelectorAll(".arrow-selector").forEach(selector => {
        const leftBtn = selector.querySelector(".arrow-left");
        const rightBtn = selector.querySelector(".arrow-right");
        if (leftBtn) {
          leftBtn.addEventListener("click", () => {
            setTimeout(updateModifierIcons, 0);
          });
        }
        if (rightBtn) {
          rightBtn.addEventListener("click", () => {
            setTimeout(updateModifierIcons, 0);
          });
        }
      });
      
      // Collapse/expand functionality
      const modeSettingsToggle = document.getElementById("modeSettingsToggle");
      const modeSettingsTitle = document.querySelector(".mode-settings-title");
      const settingsContainer = document.getElementById("settingsContainer");
      
      function toggleModeSettings() {
        modeSettings.classList.toggle("collapsed");
        // Update settings items in navigation system when toggled
        setTimeout(() => {
          if (window.updateSettingsItems) {
            window.updateSettingsItems();
          }
        }, 0);
      }
      
      if (modeSettingsToggle) {
        modeSettingsToggle.addEventListener("click", (e) => {
          e.stopPropagation();
          toggleModeSettings();
        });
      }
      
      if (modeSettingsTitle) {
        modeSettingsTitle.addEventListener("click", (e) => {
          // Only toggle if clicking on the title itself, not the button
          if (e.target === modeSettingsTitle || e.target === modeSettingsTitle.querySelector("span")) {
            toggleModeSettings();
          }
        });
      }
      
      // Arrow key navigation for modifiers (keyboard support for arrow selectors)
      const livesSelector = document.querySelector('[data-setting="lives"]');
      const fadingModeSelector = document.querySelector('[data-setting="fadingMode"]');
      const startQuestionSelector = document.querySelector('[data-setting="startQuestion"]');
      
      // Make arrow selectors focusable and keyboard navigable
      if (livesSelector) {
        livesSelector.setAttribute("tabindex", "0");
        const livesSelect = document.getElementById("lives");
        const livesValue = document.getElementById("livesValue");
        livesSelector.addEventListener("keydown", (e) => {
          if (e.key === "ArrowLeft") {
            e.preventDefault();
            cycleSelectOption(livesSelect, 'left', livesValue);
          } else if (e.key === "ArrowRight") {
            e.preventDefault();
            cycleSelectOption(livesSelect, 'right', livesValue);
          }
        });
      }
      
      if (fadingModeSelector) {
        fadingModeSelector.setAttribute("tabindex", "0");
        const fadingModeSelect = document.getElementById("fadingMode");
        const fadingModeValue = document.getElementById("fadingModeValue");
        fadingModeSelector.addEventListener("keydown", (e) => {
          if (e.key === "ArrowLeft") {
            e.preventDefault();
            cycleSelectOption(fadingModeSelect, 'left', fadingModeValue);
          } else if (e.key === "ArrowRight") {
            e.preventDefault();
            cycleSelectOption(fadingModeSelect, 'right', fadingModeValue);
          }
        });
      }
      
      if (startQuestionSelector) {
        startQuestionSelector.setAttribute("tabindex", "0");
        const startQuestionSelect = document.getElementById("startQuestion");
        const startQuestionValue = document.getElementById("startQuestionValue");
        startQuestionSelector.addEventListener("keydown", (e) => {
          if (e.key === "ArrowLeft") {
            e.preventDefault();
            cycleSelectOption(startQuestionSelect, 'left', startQuestionValue);
          } else if (e.key === "ArrowRight") {
            e.preventDefault();
            cycleSelectOption(startQuestionSelect, 'right', startQuestionValue);
          }
        });
      }
      
      // Time Multiplier slider navigation
      if (timeMultiplierSlider) {
        timeMultiplierSlider.addEventListener("keydown", (e) => {
          if (e.key === "ArrowLeft") {
            e.preventDefault();
            const currentValue = parseFloat(timeMultiplierSlider.value);
            const step = parseFloat(timeMultiplierSlider.step);
            const min = parseFloat(timeMultiplierSlider.min);
            const newValue = Math.max(min, currentValue - step);
            timeMultiplierSlider.value = newValue;
            timeMultiplierSlider.dispatchEvent(new Event('input', { bubbles: true }));
          } else if (e.key === "ArrowRight") {
            e.preventDefault();
            const currentValue = parseFloat(timeMultiplierSlider.value);
            const step = parseFloat(timeMultiplierSlider.step);
            const max = parseFloat(timeMultiplierSlider.max);
            const newValue = Math.min(max, currentValue + step);
            timeMultiplierSlider.value = newValue;
            timeMultiplierSlider.dispatchEvent(new Event('input', { bubbles: true }));
          }
        });
      }
    })();
  </script>
  <script>
    // In-browser mock for /lunar: intercepts fetch calls to /lunar and returns
    // a mapping-based response when the server is unreachable. This lets the
    // client work when Node/server isn't running (file:// or offline).
    (function(){
      const originalFetch = window.fetch ? window.fetch.bind(window) : null;
      window.fetch = async function(input, init) {
        try {
          const reqUrl = (typeof input === 'string') ? input : (input && input.url) || '';
          const abs = new URL(reqUrl, location.href);
          // Match /lunar path (either absolute or relative)
          if (abs.pathname === '/lunar' || abs.pathname.endsWith('/lunar')) {
            const q = abs.searchParams.get('date');
            const date = q ? new Date(q) : new Date();

            // Try network first if available
            if (originalFetch) {
              try {
                const netRes = await originalFetch(input, init);
                // If network returns success, use it
                if (netRes && netRes.ok) return netRes;
                // Otherwise fall through to mock
              } catch (e) {
                // network error -> fallback to mock
              }
            }

            // Build mock response using lunar-tracker mapping (import if needed)
            try {
              let tetInfo = null;
              if (window.lunarTracker && typeof window.lunarTracker.getTetInfo === 'function') {
                tetInfo = window.lunarTracker.getTetInfo(date);
              } else {
                const mod = await import('./lunar-tracker.js');
                tetInfo = mod.getTetInfo(date);
              }
              const body = JSON.stringify({ ok: true, source: 'mock', tet: tetInfo });
              return new Response(body, { status: 200, headers: { 'Content-Type': 'application/json' } });
            } catch (e) {
              const body = JSON.stringify({ ok: false, error: 'mock-failed' });
              return new Response(body, { status: 500, headers: { 'Content-Type': 'application/json' } });
            }
          }
        } catch (e) {
          // ignore and forward to native fetch
        }
        if (originalFetch) return originalFetch(input, init);
        // If no original fetch (very old env), return 404-like response
        return new Response(null, { status: 404 });
      };
    })();
  </script>
  <script type="module">
    import { getTetInfo } from './lunar-tracker.js';

    async function getLunarInfo(date) {
      // Try server-side endpoint first
      try {
        const q = date.toISOString().slice(0, 10);
        const res = await fetch(`/lunar?date=${encodeURIComponent(q)}`);
        if (res.ok) {
          const data = await res.json();
          // server returns either lunar data or tet mapping
          if (data && data.source === 'vn-lunar' && data.lunar) {
            return { lunarMonth: data.lunar.lMonth || data.lunar.lmonth || data.lunar.month, lunarDay: data.lunar.lDay || data.lunar.lday || data.lunar.day };
          }
          if (data && data.source === 'mapping' && data.tet) {
            return { tet: data.tet };
          }
        }
      } catch (e) {
        console.warn('Server /lunar fetch failed:', e);
      }

      // Final fallback: use mapping-only tet info
      try {
        const tet = getTetInfo(date);
        return { tet };
      } catch (e) {
        return null;
      }
    }

    (async function() {
      const currentDate = new Date();

      // Regular tips
      const regularTips = [
        "You aer",
        "You are as good as you were five minutes ago",
        "Answer questions by answering the questions",
        "Maybe the true grand master is the questions you answered along the way",
        "The only way to get better is to keep playing",
        "Just try the first option, you might be right",
        "The best way to learn is to teach. Who you are teaching this to, is the question of time.",
        "Struggling? Play more.",
        "Every answer is a step towards the answer. Literally!",
        "Also try Tetris the Grand Master! (all four of it, i beg you)",
        "Every one second in Icy's Quiz Challenge is worth a thousand milliseconds in real life.",
        "You can play the Tetris the Grand Master OST if you want to experience the true power of the game. Make sure to turn off the music in the settings!",
        "Dying at the first questions? Skill issue.",
        "There is gamepad support! Use your controller to play!",
        "You can also play with your keyboard! Use the arrow keys to navigate the options and enter to submit.",
        "'maybe if someone links their brain with the computer, they can play as fast as a tas; - not the dev",
        "The answer is not always the first option. But the first option is often the answer.",
        "The game emphasizes on speed and not accurracy as it seems. Too bad!",
        "The MS-DOS font is a way to recreate the bone blocks. You play TGM3, you should know.",
        "The game is not perfect. But it is a fun way to test your knowledge. And it is a fun way to test your skills.",
        "DO NOT PANIC IF IT LOOKS STUCK",
        "it is pretty cold here i think, can i turn the ac up?",
        "cyclone, master pikii, and korean stacking",
        "The developer team is always there to help you. if you need anything, just ask.",
        "What happens if you answer all questions in hell mode? Who knows!",
        "Go drink some water, you might need it.",
        "You can play with your face turning the other way as good as when you play this blindfolded.",
        "should we add a fading element mode? idk",
        "counter time attack when? (oh yea if you did one of those please send me a video)",
        "Have fun, and if you are having fun, please share your score with us!",
        "the hardest quiz site that's ever existed",
        "it only gets harder",
        "âœ…Limit quiz to 2GB of RAM",
        "is anyone even playing this?",
        "up pull pull",
        "[]",
        "are you even trying?",
        "you are not a genius, you are a human being. and that is enough.",
        "Fun fact: The midpoint between 0 and infinity is one. Which means every journey starts with a single step.",
        "STOP POSTING ABOUT ãƒ¢ã‚¨ãƒãƒ£ãƒƒã‚«ãƒ•ã‚¡ã‚¤ã‚¢! I'M TIRED OF HEARING IT!!",
        "*gently jerks your left analog stick off*",
        "think fast move fast think fast move fast"
      ];

      // Christmas tips for December
      const christmasTips = [
        "ðŸŽ„ Merry Christmas! May your scores be as high as Santa's sleigh!",
        "â„ï¸ It's snowing in the menu! Don't let it distract you from your quiz.",
        "ðŸŽ… Ho ho ho! Santa's watching your quiz performance. Be good!",
        "ðŸŽ Christmas special: Answer questions faster for extra holiday cheer!",
        "ðŸŒŸ The Christmas lights are shining bright. Can you shine brighter?",
        "ðŸ”” Jingle all the way to the top of the leaderboards!",
        "ðŸŽ„ Deck the halls with high scores and quiz mastery!",
        "â„ï¸ Winter wonderland mode activated. Stay focused on those questions!",
        "ðŸŽ… Santa's little helper: Practice makes perfect, even during holidays!",
        "ðŸŽ Gift yourself a perfect score this Christmas season!",
        "ðŸŽ„ Ho ho ho! Santa's checking his list... and your quiz stats!",
        "â„ï¸ Snowflakes falling, but your knowledge is rising!",
        "ðŸŽ… Dear Santa, please bring me more quiz questions... wait, no!",
        "ðŸŽ Unwrap the gift of knowledge this holiday season!",
        "ðŸŒŸ Twinkle like the Christmas lights with your quiz brilliance!"
      ];

      // New Year's tips for January 1st
      const newYearTips = [
        "ðŸŽ‰ Happy New Year! Start the year with a bang... of correct answers!",
        "ðŸŽŠ Fireworks in the menu! But the real explosion is your knowledge!",
        "ðŸ¥‚ Cheers to a new year of quiz mastery and high scores!",
        "ðŸŽ† New Year's special: Set off your own fireworks with perfect answers!",
        "ðŸŒ… Welcome the new year with fresh questions and renewed determination!",
        "ðŸŽ‰ Ring in the new year by ringing up those points!",
        "ðŸŽŠ Party like it's 1999... wait, no, party like it's quiz time!",
        "ðŸ¥‚ Toast to your quiz skills improving in the new year!",
        "ðŸŽ† Let your answers sparkle like New Year's fireworks!",
        "ðŸŒŸ New year, new questions, new high scores!"
      ];

      // Lunar New Year tips (Tet)
      const lunarNewYearTips = [
        "ðŸŽŠ ChÃºc má»«ng nÄƒm má»›i! May your Tet be filled with joy and high scores!",
        "ðŸ§§ Red envelopes bring luck! May your answers bring you fortune!",
        "ðŸ‰ Dragon dances and lion dances! Dance through the questions with skill!",
        "ðŸŽ† Fireworks light up the sky! Let your correct answers light up the leaderboard!",
        "ðŸ¥¢ Dumplings for good luck! May your quiz dumplings be filled with correct answers!",
        "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Family gatherings and feasts! Gather points like family gathers for Tet!",
        "ðŸŒ¸ Peach blossoms bloom! May your knowledge bloom like spring flowers!",
        "ðŸª Kite flying in the wind! Let your scores soar high like kites!",
        "ðŸŽ­ Traditional masks and costumes! Mask your wrong answers with correct ones!",
        "ðŸœ Noodle dishes for long life! May your quiz streak be as long as longevity noodles!",
        "ðŸŽŠ Tet holiday cheer! Celebrate with perfect quiz performances!",
        "ðŸ§§ Lucky money for prosperity! Earn points like collecting lucky money!",
        "ðŸ² Year of the Dragon/Rabbit/etc.! Channel the spirit of the zodiac in your answers!",
        "ðŸŒº Tropical flowers and decorations! Decorate your score with perfect answers!",
        "ðŸ¥® Mooncakes for reunion! Reunite with high scores this Tet season!"
      ];


      // Combine tips based on season
      let tips = [...regularTips];
      if (currentDate.getMonth() === 11) { // December
        tips = tips.concat(christmasTips);
      }
      if (currentDate.getMonth() === 0 && currentDate.getDate() === 1) { // January 1st
        tips = tips.concat(newYearTips);
      }

      // Check lunar date using server/CDN/mapping fallbacks
      let isLunarNewYear = false;
      try {
        const lunar = await getLunarInfo(currentDate);
        if (lunar) {
          if (lunar.lunarMonth != null && lunar.lunarDay != null) {
            isLunarNewYear = (lunar.lunarMonth === 12 && lunar.lunarDay >= 27) || (lunar.lunarMonth === 1 && lunar.lunarDay <= 5);
          } else if (lunar.tet && lunar.tet.isTet) {
            isLunarNewYear = true;
          }
        }
      } catch (e) {
        console.warn('Lunar detection error:', e);
      }

      if (isLunarNewYear) {
        tips = [...lunarNewYearTips]; // Override with only lunar new year tips
      }

      // Apply seasonal effects
      if (currentDate.getMonth() === 11) { // December
        document.body.classList.add('christmas-mode');
        // Add snowfall effect
        const snowfallContainer = document.createElement('div');
        snowfallContainer.className = 'snowfall-container';
        for (let i = 0; i < 10; i++) {
          const snowflake = document.createElement('div');
          snowflake.className = 'snowflake';
          snowflake.textContent = 'â„';
          snowflake.style.left = Math.random() * 100 + '%';
          snowflake.style.animationDelay = Math.random() * 10 + 's';
          snowfallContainer.appendChild(snowflake);
        }
        document.body.appendChild(snowfallContainer);
      }

      if (currentDate.getMonth() === 0 && currentDate.getDate() === 1) { // January 1st
        document.body.classList.add('newyear-mode');
        // Add fireworks effect
        const fireworksContainer = document.createElement('div');
        fireworksContainer.className = 'fireworks-container';
        const emojis = ['ðŸŽ†', 'ðŸŽ‡', 'âœ¨'];
        for (let i = 0; i < 10; i++) {
          const firework = document.createElement('div');
          firework.className = 'firework';
          firework.textContent = emojis[Math.floor(Math.random() * emojis.length)];
          firework.style.left = Math.random() * 100 + '%';
          firework.style.top = Math.random() * 100 + '%';
          firework.style.animationDelay = Math.random() * 5 + 's';
          fireworksContainer.appendChild(firework);
        }
        document.body.appendChild(fireworksContainer);
      }

      // Lunar New Year effects (fireworks for Tet)
      if (isLunarNewYear) {
        document.body.classList.add('lunar-newyear-mode');
        // Add fireworks effect for Lunar New Year
        const lunarFireworksContainer = document.createElement('div');
        lunarFireworksContainer.className = 'fireworks-container';
        const tetEmojis = ['ðŸŽ†', 'ðŸŽ‡', 'âœ¨', 'ðŸ§§', 'ðŸ²'];
        let numFireworks = 12;
        // Extra fireworks on the first day of Tet
        if (lunar && lunar.lunarMonth === 1 && lunar.lunarDay === 1) {
          numFireworks = 20;
          tetEmojis.push('ðŸŽŠ', 'ðŸ¥³', 'ðŸŽ‰');
        }
        for (let i = 0; i < numFireworks; i++) {
          const firework = document.createElement('div');
          firework.className = 'firework';
          firework.textContent = tetEmojis[Math.floor(Math.random() * tetEmojis.length)];
          firework.style.left = Math.random() * 100 + '%';
          firework.style.top = Math.random() * 100 + '%';
          firework.style.animationDelay = Math.random() * 6 + 's';
          lunarFireworksContainer.appendChild(firework);
        }
        document.body.appendChild(lunarFireworksContainer);
      }

      const tipsContainer = document.getElementById("tipsContainer");
      const tipsText = document.getElementById("tipsText");
      let lastTipIndex = -1;

      function showRandomTip() {
        let randomIndex;
        // Ensure we don't show the same tip twice in a row
        do {
          randomIndex = Math.floor(Math.random() * tips.length);
        } while (randomIndex === lastTipIndex && tips.length > 1);

        lastTipIndex = randomIndex;
        if (tipsText) tipsText.textContent = tips[randomIndex];
      }

      // Show first random tip immediately
      showRandomTip();

      // Show random tips every 8 seconds
      setInterval(showRandomTip, 8000);
    })();
  </script>
  <script type="module" src="hm.js"></script>
  <script type="module" src="loadBackground.js"></script>
  <script type="module" src="loadTheme.js"></script>
  <script type="module">
    // Apply theme colors to mode settings menu
    
    // Theme color mapping
    const themeColors = {
      'green': '#90ee90',
      'purple': '#dda0dd',
      'orange': '#ff8c42',
      'red': '#ff6b6b',
      'pink': '#ffc0cb',
      'yellow': '#ffff00',
      'default': '#dbffff'
    };
    
    // Get theme color from body class or user profile
    function getThemeColor() {
      // Check body class first (already applied by loadTheme.js)
      const body = document.body;
      for (const theme in themeColors) {
        if (theme !== 'default' && body.classList.contains(`theme-${theme}`)) {
          return themeColors[theme];
        }
      }
      return themeColors['default'];
    }
    
    // Apply theme colors to mode settings
    function applyThemeToModeSettings() {
      const themeColor = getThemeColor();
      const modeSettings = document.getElementById('modeSettings');
      if (!modeSettings) return;
      
      // Apply to setting text and labels
      const settingTexts = modeSettings.querySelectorAll('.setting-text');
      settingTexts.forEach(el => {
        el.style.color = themeColor;
      });
      
      // Apply to setting descriptions
      const settingDescriptions = modeSettings.querySelectorAll('.setting-description');
      settingDescriptions.forEach(el => {
        el.style.color = themeColor;
        el.style.opacity = '0.8';
      });
      
      // Apply to mode settings title
      const modeSettingsTitle = modeSettings.querySelector('.mode-settings-title span');
      if (modeSettingsTitle) {
        modeSettingsTitle.style.color = themeColor;
      }
      
      // Helper to convert hex to rgba
      function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }
      
      // Apply to arrow buttons
      const arrowButtons = modeSettings.querySelectorAll('.arrow-btn');
      arrowButtons.forEach(btn => {
        btn.style.color = themeColor;
        btn.style.borderColor = themeColor;
        btn.style.backgroundColor = hexToRgba(themeColor, 0.2);
        btn.style.opacity = '1';
        
        // Remove existing theme hover listeners if any
        if (btn._themeHoverEnter) {
          btn.removeEventListener('mouseenter', btn._themeHoverEnter);
          btn.removeEventListener('mouseleave', btn._themeHoverLeave);
        }
        
        // Add hover effects
        btn._themeHoverEnter = function() {
          this.style.backgroundColor = hexToRgba(themeColor, 0.4);
          this.style.borderColor = themeColor;
          this.style.boxShadow = `0 0 8px ${hexToRgba(themeColor, 0.6)}`;
        };
        btn._themeHoverLeave = function() {
          this.style.backgroundColor = hexToRgba(themeColor, 0.2);
          this.style.boxShadow = 'none';
        };
        
        btn.addEventListener('mouseenter', btn._themeHoverEnter);
        btn.addEventListener('mouseleave', btn._themeHoverLeave);
      });
      
      // Apply to mode settings toggle button
      const modeSettingsToggle = document.getElementById('modeSettingsToggle');
      if (modeSettingsToggle) {
        modeSettingsToggle.style.color = themeColor;
        modeSettingsToggle.style.borderColor = themeColor;
        modeSettingsToggle.style.backgroundColor = hexToRgba(themeColor, 0.2);
        
        // Remove existing theme hover listeners if any
        if (modeSettingsToggle._themeHoverEnter) {
          modeSettingsToggle.removeEventListener('mouseenter', modeSettingsToggle._themeHoverEnter);
          modeSettingsToggle.removeEventListener('mouseleave', modeSettingsToggle._themeHoverLeave);
        }
        
        // Add hover effects
        modeSettingsToggle._themeHoverEnter = function() {
          this.style.backgroundColor = hexToRgba(themeColor, 0.4);
          this.style.borderColor = themeColor;
          this.style.boxShadow = `0 0 8px ${hexToRgba(themeColor, 0.6)}`;
        };
        modeSettingsToggle._themeHoverLeave = function() {
          this.style.backgroundColor = hexToRgba(themeColor, 0.2);
          this.style.boxShadow = 'none';
        };
        
        modeSettingsToggle.addEventListener('mouseenter', modeSettingsToggle._themeHoverEnter);
        modeSettingsToggle.addEventListener('mouseleave', modeSettingsToggle._themeHoverLeave);
      }
      
      // Apply to selector values
      const selectorValues = modeSettings.querySelectorAll('.selector-value');
      selectorValues.forEach(el => {
        el.style.color = themeColor;
      });
      
      // Apply to slider values
      const sliderValues = modeSettings.querySelectorAll('.slider-value');
      sliderValues.forEach(el => {
        el.style.color = themeColor;
      });
    }
    
    // Apply theme when page loads or theme changes
    function initThemeApplication() {
      // Wait for body to have theme class
      const checkTheme = setInterval(() => {
        if (document.body.classList.length > 0 || document.body.classList.contains('theme-default')) {
          clearInterval(checkTheme);
          applyThemeToModeSettings();
        }
      }, 100);
      
      // Also apply after a delay to ensure theme is loaded
      setTimeout(() => {
        clearInterval(checkTheme);
        applyThemeToModeSettings();
      }, 1000);
    }
    
    // Watch for theme class changes
    let observer;
    if (document.body) {
      observer = new MutationObserver(() => {
        applyThemeToModeSettings();
      });
      observer.observe(document.body, {
        attributes: true,
        attributeFilter: ['class']
      });
      initThemeApplication();
    } else {
      document.addEventListener('DOMContentLoaded', () => {
        observer = new MutationObserver(() => {
          applyThemeToModeSettings();
        });
        observer.observe(document.body, {
          attributes: true,
          attributeFilter: ['class']
        });
        initThemeApplication();
      });
    }
  </script>
</html>
